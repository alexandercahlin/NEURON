<p>
<h1><a name="pointprocesses">pointprocesses</a></h1>
<pre>
<a href="../1nrn.html#neuron">neuron</a>
   <a href="mech.html#APCount">APCount</a>        <a href="mech.html#ExpSyn">ExpSyn</a>         <a href="mech.html#IntFire2">IntFire2</a>       <a href="mech.html#SEClamp">SEClamp</a>        
   <a href="mech.html#AlphaSynapse">AlphaSynapse</a>   <a href="mech.html#IClamp">IClamp</a>         <a href="mech.html#IntFire4">IntFire4</a>       <a href="mech.html#VClamp">VClamp</a>         
   <a href="mech.html#Exp2Syn">Exp2Syn</a>        <a href="mech.html#IntFire1">IntFire1</a>       <a href="mech.html#NetStim">NetStim</a>        <a href="mech.html#general">general</a>        
</pre>
<h2>DESCRIPTION</h2>
Built-in POINT_PROCESS models and ARTIFICIAL_CELL models are listed above.
The user may add other classes of those types using mod files. Some properties
and functions that are available for all POINT_PROCESS models are described
under <a href="mech.html#general">general</a> .
<h2>SEE ALSO</h2>
<a href="../stdrun/pointman.html#PointProcessManager">PointProcessManager</a>
<p><hr><p>
<h1><a name="general">general</a></h1>
<pre>
<a href="mech.html#pointprocesses">pointprocesses</a>
   <a href="mech.html#get_loc">get_loc</a>        <a href="mech.html#get_segment">get_segment</a>    <a href="mech.html#has_loc">has_loc</a>        <a href="mech.html#loc">loc</a>            
</pre>
<p><hr><p>
<h1><a name="get_loc">get_loc</a></h1>
<pre>
<a href="mech.html#general">general</a>
</pre>
<h2>SYNTAX</h2>
<code>{ x = pnt.get_loc() stmt pop_section()}</code><br>
<h2>DESCRIPTION</h2>
get_loc() pushes the section containing the POINT_PROCESS instance, pnt,
onto the section stack (makes it the currently accessed section), and
returns the position (ranging from 0 to 1) of the POINT_PROCESS instance.
The section stack should be popped when the section is no longer needed.
Note that the braces are necessary if the statement is typed at the top
level since the section stack is automatically popped when waiting for
user input.
<h2>SEE ALSO</h2>
<a href="secspec.html#pop_section">pop_section</a>
<a href="mech.html#get_segment">get_segment</a>
<p>
<p><hr><p>
<h1><a name="get_segment">get_segment</a></h1>
<pre>
<a href="mech.html#general">general</a>
</pre>
<h2>SYNTAX</h2>
<code>pyseg = pnt.get_segment()</code><br>
<h2>DESCRIPTION</h2>
A more pythonic version of <a href="mech.html#get_loc">get_loc</a> in that it returns a python segment object
without pushing the section stack. From a segment object one can get the
section with <code>pyseg.sec</code> and the position with <code>pyseg.x</code>. If the
point process is not located anywhere, the return value is None.
<h2>BUGS</h2>
Segment objects become invalid if nseg changes. Discard them as soon as
possible and do not keep them around.
<p>
<p><hr><p>
<h1><a name="loc">loc</a></h1>
<pre>
<a href="mech.html#general">general</a>
</pre>
<h2>SYNTAX</h2>
<code>pnt.loc(x)</code><br>
<h2>DESCRIPTION</h2>
Moves the POINT_PROCESS instance, pnt, to the center of the segment containing
x of the currently accessed section.
<p>
<p><hr><p>
<h1><a name="has_loc">has_loc</a></h1>
<pre>
<a href="mech.html#general">general</a>
</pre>
<h2>SYNTAX</h2>
<code>b = pnt.has_loc()</code><br>
<h2>DESCRIPTION</h2>
Returns 1 if the POINT_PROCESS instance, pnt, is located in some section,
otherwise, 0.
<p>
<p><hr><p>
<h1><a name="IClamp">IClamp</a></h1>
<pre>
<a href="mech.html#pointprocesses">pointprocesses</a>
</pre>
<h2>SYNTAX</h2>
<code>stimobj = new IClamp(x)</code><br>
<code>del -- ms</code><br>
<code>dur -- ms</code><br>
<code>amp -- nA</code><br>
<code>i -- nA</code><br>
<h2>DESCRIPTION</h2>
See $NEURONHOME/src/nrnoc/stim.mod
<p>
Single pulse current clamp point process. This is an electrode current
so positive amp depolarizes the cell. i is set to amp when t is within
the closed interval del to del+dur. Time varying current stimuli can
be simulated by setting del=0, dur=1e9 and playing a vector into amp
with the <a href="../general/classes/random.html#play">play</a> <a href="../stdrun/0stdrun.html#Vector">Vector</a> method.
<p><hr><p>
<h1><a name="AlphaSynapse">AlphaSynapse</a></h1>
<pre>
<a href="mech.html#pointprocesses">pointprocesses</a>
</pre>
<h2>SYNTAX</h2>
<code>syn = new AlphaSynapse(x)</code><br>
<code>syn.onset --- ms</code><br>
<code>syn.tau	 --- ms</code><br>
<code>syn.gmax ---	umho</code><br>
<code>syn.e	---	mV</code><br>
<code>syn.i	---	nA</code><br>
<h2>DESCRIPTION</h2>
See $NEURONHOME/src/nrnoc/syn.mod. The comment in this file reads:
<pre>
synaptic current with alpha function conductance defined by
        i = g * (v - e)      i(nanoamps), g(micromhos);
        where
         g = 0 for t < onset and
         g = gmax * (t - onset)/tau * exp(-(t - onset - tau)/tau)
          for t > onset
this has the property that the maximum value is gmax and occurs at
 t = delay + tau.
</pre>
<p><hr><p>
<h1><a name="VClamp">VClamp</a></h1>
<pre>
<a href="mech.html#pointprocesses">pointprocesses</a>
</pre>
<h2>SYNTAX</h2>
<code>obj = new VClamp(x)</code><br>
<code>dur[3]</code><br>
<code>amp[3]</code><br>
<code>gain, rstim, tau1, tau2</code><br>
<code>i</code><br>
<h2>DESCRIPTION</h2>
Two electrode voltage clamp.
<p>
See $NEURONHOME/src/nrnoc/vclmp.mod . The comment in this file reads:
<p>
Voltage clamp with three levels. Clamp is on at time 0, and off at time
dur[0]+dur[1]+dur[2]. When clamp is off the injected current is 0.
Do not insert several instances of this model at the same location in
order to
make level changes. That is equivalent to independent clamps and they will
have incompatible internal state values.
<p>
The control amplifier has the indicated gain and time constant.  The
input amplifier is ideal.
<pre>
<p>
                 tau2
                 gain
                +-|\____rstim____>to cell
-amp --'\/`-------|/
                |
                |----||---
                |___    __|-----/|___from cell
                    `'`'        \|
                    tau1
<p>
</pre>
<p>
The clamp has a three states which are the voltage input of the gain amplifier,
the voltage output of the gain amplfier, and the voltage output of the 
measuring amplifier.
A good initial condition for these voltages are 0, 0, and v respectively.
<p>
This model is quite stiff.  For this reason the current is updated
within the solve block before updating the state of the clamp. This
gives the correct value of the current on exit from fadvance(). If we
didn't do this and
instead used the values computed in the breakpoint block, it
would look like the clamp current is much larger than it actually is
since it
doesn't take into account the change in voltage within the timestep, ie
equivalent to an almost infinite capacitance.
Also, because of stiffness, do not use this model except with secondorder=0.
                 
This model makes use of implementation details of how models are interfaced
to neuron. At some point I will make the translation such that these kinds
of models can be handled straightforwardly.
                    
Note that since this is an electrode current model v refers to the
internal potential which is equivalent to the membrane potential v when
there is no extracellular membrane mechanism present but is v+vext when
one is present.
Also since i is an electrode current,
positive values of i depolarize the cell. (Normally, positive membrane currents
are outward and thus hyperpolarize the cell)
<p><hr><p>
<h1><a name="SEClamp">SEClamp</a></h1>
<pre>
<a href="mech.html#pointprocesses">pointprocesses</a>
</pre>
<h2>SYNTAX</h2>
<code>clampobj = new SEClamp(.5)</code><br>
<code>dur1 dur2 dur3 -- ms</code><br>
<code>amp1 amp2 amp3 -- mV</code><br>
<code>rs -- MOhm</code><br>
<code></code><br>
<code>vc -- mV</code><br>
<code>i -- nA</code><br>
<h2>DESCRIPTION</h2>
Single electrode voltage clamp with three levels.
<p>
See $NEURONHOME/src/nrnoc/svclmp.mod. The comment in this file reads:
<p>
Single electrode Voltage clamp with three levels.
Clamp is on at time 0, and off at time
dur1+dur2+dur3. When clamp is off the injected current is 0.
The clamp levels are amp1, amp2, amp3.
i is the injected current, vc measures the control voltage)
Do not insert several instances of this model at the same location in
order to
make level changes. That is equivalent to independent clamps and they will
have incompatible internal state values.
The electrical circuit for the clamp is exceedingly simple:
<blockquote><pre>
vc ---'\/\/`--- cell
        rs
</pre></blockquote>
Note that since this is an electrode current model v refers to the
internal potential which is equivalent to the membrane potential v when
there is no extracellular membrane mechanism present but is v+vext when
one is present.
Also since i is an electrode current,
positive values of i depolarize the cell. (Normally, positive membrane currents
are outward and thus hyperpolarize the cell)
<p>
This model is careful to ensure the clamp current is properly computed
relative to the membrane voltage on exit from fadvance and can therefore
be used with time varying control potentials. Like <a href="mech.html#VClamp">VClamp</a> it is suitable
for <a href="../general/classes/vector/vect.html#play">play</a> ing a Vector into the control potential.
<p>
The following example compares the current that results from
clamping an action potential originally elicited by a current pulse.<br>
<a href="svclmp.hoc">execute following example</a>
<blockquote><pre>
// setup for three simulations
create s1, s2, s3 // will be stimulated by IClamp, SEClamp, and VClamp
forall {insert hh diam=3 L=3 }
objref c1, c2, c3, ap, apc
s1 c1 = new IClamp(.5)
s2 c2 = new SEClamp(.5)
s3 c3 = new VClamp(.5)
{c1.dur=.1 c1.amp=.3}
{c2.dur1 = 1 c2.rs=.01 }
{c3.dur[0] = 1}

// record an action potential
ap = new Vector()
ap.record(&amp;s1.v(.5))
finitialize(-65)   
while(t&lt;1) { fadvance() }

// do the three cases while playing the recorded ap
apc = ap.c	// unfortunately can't play into two variables so clone it.
ap.play_remove()  
ap.play(&amp;c2.amp1)
apc.play(&amp;c3.amp[0])
finitialize(-65)
while(t&lt;.4) {
        fadvance()
        print s1.v, s2.v, s3.v, c1.i, c2.i, c3.i
}
</pre></blockquote>
<p><hr><p>
<h1><a name="APCount">APCount</a></h1>
<pre>
<a href="mech.html#pointprocesses">pointprocesses</a>
</pre>
<h2>SYNTAX</h2>
<code>apc = new APCount(x)</code><br>
<code>apc.thresh ---	mV</code><br>
<code>apc.n</code><br>
<code>apc.time --- ms</code><br>
<code>apc.record(vector)</code><br>
<h2>DESCRIPTION</h2>
Counts the number of times the voltage at its location crosses a
threshold voltage in the positive direction. n contains the count
and time contains the time of last crossing.
<p>
If a Vector is attached to the apc, then it is resized to 0 when the
INITIAL block is called and the times of threshold crossing are
appended to the Vector. apc.record() will stop recording into the vector.
The apc is not notified if the vector is freed but this can be fixed if
it is convenient to add this feature.
<p>
See $NEURONHOME/src/nrnoc/apcount.mod
<p><hr><p>
<h1><a name="ExpSyn">ExpSyn</a></h1>
<pre>
<a href="mech.html#pointprocesses">pointprocesses</a>
</pre>
<h2>SYNTAX</h2>
<code>syn = new ExpSyn(x)</code><br>
<code>syn.tau --- ms decay time constant</code><br>
<code>syn.e -- mV reversal potential</code><br>
<code>syn.i -- nA synaptic current</code><br>
<h2>DESCRIPTION</h2>
Synapse with discontinuous change in conductance at an event followed
by an exponential decay with time constant tau.   
<blockquote><pre>
i = G * (v - e)      i(nanoamps), g(micromhos);
  G = weight * exp(-t/tau)
</pre></blockquote>
<p>
The weight is specified
by the <a href="classes/netcon.html#weight">weight</a> field of a <a href="classes/netcon.html#NetCon">NetCon</a> object.
<p>
This synapse summates.
<p>
See $NEURONHOME/src/nrnoc/expsyn.mod
<p><hr><p>
<h1><a name="Exp2Syn">Exp2Syn</a></h1>
<pre>
<a href="mech.html#pointprocesses">pointprocesses</a>
</pre>
<h2>SYNTAX</h2>
<code>syn = new Exp2Syn(x)</code><br>
<code>syn.tau1 --- ms rise time</code><br>
<code>syn.tau2 --- ms decay time</code><br>
<code>syn.e -- mV reversal potential</code><br>
<code>syn.i -- nA synaptic current</code><br>
<h2>DESCRIPTION</h2>
Two state kinetic scheme synapse described by rise time tau1,
and decay time constant tau2. The normalized peak condductance is 1.
Decay time MUST be greater than rise time.
<p>
The kinetic scheme
<blockquote><pre>
A    -&gt;   G   -&gt;   bath
   1/tau1   1/tau2
</pre></blockquote>    
produces
a synaptic current with alpha function like conductance (if tau1/tau2
is appoximately 1)
defined by
<blockquote><pre>
i = G * (v - e)      i(nanoamps), g(micromhos);
  G = weight * factor * (exp(-t/tau2) - exp(-t/tau1))
</pre></blockquote>
The weight is specified
by the <a href="classes/netcon.html#weight">weight</a> field of a <a href="classes/netcon.html#NetCon">NetCon</a> object.
The factor is defined so that the normalized peak is 1.
If tau2 is close to tau1 
this has the property that the maximum value is weight and occurs at
t = tau1.
<p>
Because the solution is a sum of exponentials, the
coupled equations for the kinetic scheme
can be solved as a pair of independent equations
by the more efficient cnexp method.
<p>
This synapse summates.
<p>
See $NEURONHOME/src/nrnoc/exp2syn.mod
<p>
<p><hr><p>
<h1><a name="NetStim">NetStim</a></h1>
<pre>
<a href="mech.html#pointprocesses">pointprocesses</a>
</pre>
<h2>SYNTAX</h2>
<code>s = new NetStim(x)</code><br>
<code>s.interval ms (mean) time between spikes</code><br>
<code>s.number (average) number of spikes</code><br>
<code>s.start ms (most likely) start time of first spike</code><br>
<code>s.noise ---- range 0 to 1. Fractional randomness.</code><br>
<code>	0 deterministic, 1 intervals have negexp distribution.</code><br>
<h2>DESCRIPTION</h2>
Generates a train of presynaptic stimuli. Can serve as the source for
a NetCon. This NetStim can also be 
be triggered by an input event. i.e serve as the target of a NetCon.
If the stimulator is in the on=0 state and receives a positive weight
event, then the stimulator changes to the on=1 state and goes through
its burst sequence before changing to the on=0 state. During
that time it ignores any positive weight events. If, in the on=1 state,
the stimulator receives a negative weight event, the stimulator will
change to the off state. In the off state, it will ignore negative weight
events. A change to the on state immediately causes the first spike.
<p>
Fractional noise, 0 <= noise <= 1, means that an interval between spikes
consists of a fixed interval of duration (1 - noise)*interval plus a negexp
interval of mean duration noise*interval. Note that the most likely negexp
interval has duration 0.
<p>
Since NetStim sends events, the proper idiom for specifying it as a source
for a NetCon is
<blockquote><pre>
objref ns, nc
nc = new NetStim(.5)
ns = new NetCon(nc, target...)
</pre></blockquote>
That is, do not use <code>&nc.y</code> as the source for the netcon.
<p>
See $NEURONHOME/src/nrnoc/netstim.mod
<h2>BUGS</h2>
Prior to version 5.2.1 an attempt was made to
make the mean start time (noise > 0)
correspond to the value of start. However since it is not possible to
simulate events occurring at t < 0, these spikes were generated at t=0.
Thus the mean start time was not start and the spikes at t=0 did not
obey negexp statistics. For this reason, beginning with version 5.2.1
the semantics of start are the time of the most likely first spike and the
mean start time is start + noise*interval.
<p>
<p><hr><p>
<h1><a name="IntFire1">IntFire1</a></h1>
<pre>
<a href="mech.html#pointprocesses">pointprocesses</a>
</pre>
<h2>SYNTAX</h2>
<code>c = new IntFire1(x)</code><br>
<code>c.tau --- ms time constant</code><br>
<code>c.refrac --- ms refractory period. Minimum time between events is refrac</code><br>
<code>c.m --- state variable</code><br>
<code>c.M --- analytic value of state at current time, t</code><br>
<h2>DESCRIPTION</h2>
A point process that is equivalent to an entire integrate and fire cell.
<p>
An output
spike event is sent to all the NetCon instances which have this pointprocess
instance as their source when m >= 1
If m(t0) = m0 and an input event occurs at t1
then the value of m an infinitesimal time before the t1 event is
exp(-(t1 - t0)/tau). After the input event m(t1) = m(t1) + weight where weight
is the weight of the NetCon event.
Input events are ignored for refrac time after the spike output
event.
<p>
During the refractory period,  m = 2.
At the end of the refractory period, m = 0.
During the refractory period, the function M() returns a value of 2
for the first .5 ms and -1 for the rest of the period. Otherwise it
returns exp((t-t0)/tau)
<p>
See $NEURONHOME/src/nrnoc/intfire1.mod
<p><hr><p>
<h1><a name="IntFire2">IntFire2</a></h1>
<pre>
<a href="mech.html#pointprocesses">pointprocesses</a>
</pre>
<h2>SYNTAX</h2>
<code>c = new IntFire2(x)</code><br>
<code>c.taum --- ms membrane time constant</code><br>
<code>c.taus -- ms synaptic current time constant</code><br>
<code>c.ib -- constant current input</code><br>
<code>c.m --- membrane state variable</code><br>
<code>c.M --- analytic value of state at current time, t</code><br>
<code>c.i --- synaptic current state variable</code><br>
<code>c.I --- analytic value of synaptic current.</code><br>
<h2>DESCRIPTION</h2>
A leaky integrator with time constant taum driven by a total
current that is the sum of 
{ a user-settable constant "bias" current }
plus 
{ a net synaptic current }.
Net synaptic current decays toward 0 with time constant taus, where
taus > taum (synaptic
current decays slowly compared to the rate at which "membrane potential
m equilibrates).
When an input event with weight w arrives, the net synaptic current
changes abruptly by
the amount w. 
<p>
See $NEURONHOME/src/nrnoc/intfire2.mod
<p>
<p><hr><p>
<h1><a name="IntFire4">IntFire4</a></h1>
<pre>
<a href="mech.html#pointprocesses">pointprocesses</a>
</pre>
<h2>SYNTAX</h2>
<code>c = new IntFire4(x)</code><br>
<code>c.taue --- ms excitatory input time constant</code><br>
<code>c.taui1 --- ms inhibitory input rise time constant</code><br>
<code>c.taui2 --- ms inhibitory input fall time constant</code><br>
<code>c.taum --- membrane time constant</code><br>
<code>c.m --- membrane state variable</code><br>
<code>c.M --- analytic value of membrane state at current time, t</code><br>
<code>c.e --- excitatory current state variable</code><br>
<code>c.E --- analytic value of excitation current</code><br>
<code>c.i1 c.i2 -- inhibitory current state variables</code><br>
<code>c.I --- analytic value of inhibitory current.</code><br>
<code></code><br>
<h2>DESCRIPTION</h2>
The IntFire4 artificial cell treats excitatory input (positive weight)
events as a sudden change in
current which decays exponentially with time constant taue. Inhibitory
input (negative weight)
events are treated as an alpha function like change to the current. More
precisely the current due
to a negative weight event is the difference between two exponentials
with time constants taui1
and taui2. In the limit as taui2 approaches taui1 then the current due
to the event approaches the
alpha function. The current due to the input events is integrated with a
membrane time constant
of taum. At present there is a constraint taue < taui1 < taui2 < taum
but this may become
relaxed to taue, taui1 < taui2, taum. When the membrane potential
reaches 1, the cell fires and
the membrane potential is re-initialized to 0 and starts integrating
according to the analytic
value of the current (which does NOT depend on firing). Excitatory
events are scaled such that
an isolated event of weight 1 will produce a maximum membrane potential
of 1 (threshold) and
an isolated inhibitory event of weight -1 will produce a minimum
membrane potential of -1. 
<p>
See $NEURONHOME/src/nrnoc/intfire4.mod
<p>
<p><hr><p>
<h1><a name="mechanisms">mechanisms</a></h1>
<pre>
<a href="../1nrn.html#neuron">neuron</a>
   <a href="mech.html#capacitance">capacitance</a>    <a href="mech.html#fastpas">fastpas</a>        <a href="mech.html#pas">pas</a>            
   <a href="mech.html#extracellular">extracellular</a>  <a href="mech.html#hh">hh</a>             <a href="mech.html#setdata">setdata</a>        
</pre>
<h2>SEE ALSO</h2>
<a href="../general/keywords/ockeywor.html#insert">insert</a> <a href="../stdrun/0stdrun.html#Inserter">Inserter</a>
<p>
<p><hr><p>
<h1><a name="setdata">setdata</a></h1>
<pre>
<a href="mech.html#mechanisms">mechanisms</a>
</pre>
<h2>SYNTAX</h2>
<code>sec setdata_suffix(x)</code><br>
<h2>DESCRIPTION</h2>
If a mechanism function is called that uses RANGE variables, then the
appropriate data needed by the function must first be indicated via a setdata call.
This is unnecessary if the function uses only GLOBAL variables.
The suffix refers to the name of the mechanism. E.g. setdata_hh().
<h2>BUGS</h2>
The THREADSAFE mechanism case is a bit more complicated if the mechanism
anywhere assigns a value to a GLOBAL variable. When the user explicitly
specifies that a mechanism is THREADSAFE, those GLOBAL variables that
anywhere appear on the left hand side of an assignment statement (and there
is no such assignment with the PROTECT prefix)
are actually
thread specific variables.
Hoc access to thread specific global variables is with respect to a static
instance which is shared by
the first thread in which mechanism actually exists.
<p>
<p><hr><p>
<h1><a name="capacitance">capacitance</a></h1>
<pre>
<a href="mech.html#mechanisms">mechanisms</a>
</pre>
<h2>SYNTAX</h2>
<code>cm (uF/cm2)</code><br>
<code>i_cap (mA/cm2)</code><br>
<h2>DESCRIPTION</h2>
capacitance is a mechanism that automatically is inserted into every section.
cm is a range variable with a default value of 1.0.
i_cap is a range variable which contains the varying membrane capacitive current
during a simulation. Note that i_cap is most accurate when a variable step
integration method is used.
<p>
<p><hr><p>
<h1><a name="hh">hh</a></h1>
<pre>
<a href="mech.html#mechanisms">mechanisms</a>
</pre>
<h2>SYNTAX</h2>
<code>insert hh</code><br>
<h2>DESCRIPTION</h2>
See $NEURONHOME/src/nrnoc/hh.mod
<p>
Hodgkin-Huxley sodium, potassium, and leakage channels. Range variables
specific to this model are:
<pre>
gnabar_hh	.120 mho/cm2	Maximum specific sodium channel conductance
gkbar_hh	.036 mho/cm2	Maximum potassium channel conductance
gl_hh		.0003 mho/cm2	Leakage conductance
el_hh		-54.3 mV	Leakage reversal potential
m_hh				sodium activation state variable
h_hh				sodium inactivation state variable
n_hh				potassium activation state variable
ina_hh		mA/cm2		sodium current through the hh channels
ik_hh		mA/cm2		potassium current through the hh channels
<p>
rates_hh(v) computes the global variables [mhn]inf_hh and [mhn]tau_hh
from the rate functions. usetable_hh defaults to 1.
</pre>
This model used the na and k ions to read ena, ek and write ina, ik.
<p><hr><p>
<h1><a name="pas">pas</a></h1>
<pre>
<a href="mech.html#mechanisms">mechanisms</a>
</pre>
<h2>SYNTAX</h2>
<code>insert pas</code><br>
<code>g_pas -- mho/cm2	conductance</code><br>
<code>e_pas -- mV		reversal potential</code><br>
<code>i -- mA/cm2		non-specific current</code><br>
<h2>DESCRIPTION</h2>
See $NEURONHOME/src/nrnoc/passive.mod
<p>
Passive membrane channel.
<p><hr><p>
<h1><a name="fastpas">fastpas</a></h1>
<pre>
<a href="mech.html#mechanisms">mechanisms</a>
</pre>
See $NEURONHOME/src/nrnoc/passive0.c
<p>
Passive membrane channel. Same as the <a href="mech.html#pas">pas</a> mechanism but hand coded to
be a bit faster (avoids the wasteful numerical derivative computation of
the conductance and does not save the current). Generally not worth
using since passive channel computations are not usually the rate limiting
step of a simulation.
<p>
<p><hr><p>
<h1><a name="extracellular">extracellular</a></h1>
<pre>
<a href="mech.html#mechanisms">mechanisms</a>
</pre>
<h2>SYNTAX</h2>
<code>insert extracellular</code><br>
<code>vext[2]	-- mV</code><br>
<code>i_membrane -- mA/cm2</code><br>
<code>xraxial[2] -- MOhms/cm</code><br>
<code>xg[2]	-- mho/cm2</code><br>
<code>xc[2]	-- uF/cm2</code><br>
<code>e_extracellular -- mV</code><br>
<h2>DESCRIPTION</h2>
Adds two layers of extracellular field to the section. Vext is
solved simultaneously with the v. When the extracellular mechanism
is present, v refers to the membrane potential and vext (i.e. vext[0])
refers to
the extracellular potential just next to the membrane. Thus the
internal potential is v+vext (but see BUGS).
<p>
This mechanism is useful for simulating the stimulation with
extracellular electrodes, response in the presence of an extracellular
potential boundary condition computed by some external program, leaky
patch clamps, incomplete seals in the myelin sheath along with current
flow in the space between the myelin and the axon. And is required
when connecting <a href="classes/linmod.html#LinearMechanism">LinearMechanism</a> (e.g. a circuit built with
the NEURONMainMenu/Build/LinearCircuit) to extracellular nodes.
<p>
i_membrane correctly does not include contributions from ELECTRODE_CURRENT
point processes.
<p>
The figure illustrates the form the electrical equivalent circuit
when this mechanism is present. Note that previous documentation
was incorrect in showing that e_extracellular was in series with
the xg[nlayer-1],xc[nlayer-1] parallel combination.
In fact it has always been the case
that e_extracellular was in series with xg[nlayer-1] and xc[nlayer-1]
was in parallel
with that series combination.
<p>
Note: The only reason the standard
distribution is built with nlayer=2 is so that when only a single
layer is needed (the usual case), then e_extracellular is consistent
with the previous documentation with the old default nlayer=1.
<p>
e_extracellular is connected in series with the conductance of
the last extracellular layer.
With two layers the equivalent circuit looks like:
<p>
<pre>
<p>
          Ra		
o/`--o--'\/\/`--o--'\/\/`--o--'\/\/`--o--'\o vext + v
     |          |          |          |     
    ---        ---        ---        ---
   |   |      |   |      |   |      |   |
    ---        ---        ---        ---
     |          |          |          |     
     |          |          |          |     i_membrane     
     |  xraxial |          |          |
 /`--o--'\/\/`--o--'\/\/`--o--'\/\/`--o--'\ vext
     |          |          |          |     
    ---        ---        ---        ---     xc and xg
   |   |      |   |      |   |      |   |    in  parallel
    ---        ---        ---        ---
     |          |          |          |     
     |          |          |          |     
     |xraxial[1]|          |          |     
 /`--o--'\/\/`--o--'\/\/`--o--'\/\/`--o--'\ vext[1]
     |          |          |          |     
    ---        ---        ---        ---     the series xg[1], e_extracellular
   |   |      |   |      |   |      |   |    combination is in parallel with
   |  ---     |  ---     |  ---     |  ---   the xc[1] capacitance. This is
   |   -      |   -      |   -      |   -    identical to a membrane with
    ---        ---        ---        ---     cm, g_pas, e_pas
     |          |          |          |     
-------------------------------------------- ground
<p>
</pre>
<p>
Extracellular potentials do a great deal
of violence to one's intuition and it is important that the user
carefully consider the results of simulations that use them.
It is best to start out believing that there are bugs in the method
and attempt to prove their existence.
<p>
See $NEURONHOME/src/nrnoc/extcell.c
and $NEURONHOME/examples/nrnoc/extcab*.hoc.
<p>
NEURON can be compiled with any number of extracellular layers.
See below.
<h2>BUGS</h2>
xcaxial is also defined but is not implemented. If you need those
then add them with the <a href="classes/linmod.html#LinearMechanism">LinearMechanism</a> .
<p>
Prior versions of this document indicated that
e_extracellular is in series with the parallel (xc,xg)
pair. In fact it was in series with xg of the layer.
The above equivalent circuit has been changed to reflect the truth
about the implementation.
<p>
In v4.3.1 2000/09/06 and before
vext(0) and vext(1) are the voltages at the centers of the first and
last segments instead of the zero area nodes.
<p>
Now the above bug is fixed and
vext(0) and vext(1) are the voltages at the zero area nodes.
<p>
From extcell.c the comment is:
<pre>
        i_membrane = sav_g * ndlist[i]->v + sav_rhs;
#if 1
        /* i_membrane is a current density (mA/cm2). However  
           it contains contributions from Non-ELECTRODE_CURRENT
           point processes. i_membrane(0) and i_membrane(1) will
           return the membrane current density at the points
           .5/nseg and 1-.5/nseg respectively. This can cause
           confusion if non-ELECTRODE_CURRENT point processes
           are located at these 0-area nodes since 1) not only
           is the true current density infinite, but 2) the 
           correct absolute current is being computed here 
             at the x=1 point but is not available, and 3) the 
           correct absolute current at x=0 is not computed
           if the parent is a rootnode or there is no
           extracellular mechanism for the parent of this
           section. Thus, if non-ELECTRODE_CURRENT point processes
           eg synapses, are being used it is not a good idea to
           insert them at the points x=0 or x=1
        */
#else
           i_membrane *= ndlist[i]->area;
           /* i_membrane is nA for every segment. This is different
              from all other continuous mechanism currents and
              same as PointProcess currents since it contains
              non-ELECTRODE_CURRENT point processes and may
              be non-zero for the zero area nodes.
           */
#endif
<p>
</pre>
<p>
<p>
In v4.3.1 2000/09/06 and before
extracellular layers will not be connected across sections unless
the parent section of the connection contains the extracellular
mechanism. This is because the 0 area node of the connection is
"owned" by the parent section. In particular, root nodes never contain
extracellular mechanisms and thus multiple sections connected to the
root node always appear to be extracellularly disconnected.
This bug has been fixed. However it is still the case that
vext(0) can be non-zero only if the section owning the 0 node has had
the extracellular mechanism inserted. It is best to have every section
in a cell contain the extracellular mechanism if any one of them does
to avoid confusion with regard to (the in fact correct) boundary conditions.
<p>
<p>
<p>
<h2>SYNTAX</h2>
<code>nrn/src/nrnoc/options.h</code><br>
<code>#define EXTRACELLULAR   2       /* number of extracellular layers */</code><br>
<code></code><br>
<code>insert extracellular</code><br>
<code>vext[i]	-- mV</code><br>
<code>i_membrane -- mA/cm2</code><br>
<code>xraxial[i] -- MOhms/cm</code><br>
<code>xg[i]	-- mho/cm2</code><br>
<code>xc[i]	-- uF/cm2</code><br>
<code>e_extracellular -- mV</code><br>
<code></code><br>
<h2>DESCRIPTION</h2>
If other than 2 extracellular layers is desired, you may recompile the
program by changing the nrn/src/nrnoc/options.h line
#define EXTRACELLULAR 2
to the number of layers desired. Be sure to recompile both nrnoc and nrniv
as well as any user defined .mod files that use the ELECTRODE_CURRENT statement.
<p>
Note that vext is a synonym in hoc for vext[0]. Since the default value for
xg[i] = 1e9 all layers start out tightly connected to ground so
previous single layer extracellular simulations should produce the same
results if either xc or e_extracellular was 0
<p>
e_extracellular is connected in series with the conductance of
the last extracellular layer.
<p><hr><p>
<date>
neuron/neuron/mech.hel : Sep 21 09:30
