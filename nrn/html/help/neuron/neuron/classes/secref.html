<h1><a name="SectionRef">SectionRef</a></h1>
<pre>
<a href="../../1nrn.html#classes">classes</a>
   <a href="secref.html#child">child</a>          <a href="secref.html#has_trueparent">has_trueparent</a>  <a href="secref.html#parent">parent</a>        <a href="secref.html#trueparent">trueparent</a>     
   <a href="secref.html#exists">exists</a>         <a href="secref.html#is_cas">is_cas</a>         <a href="secref.html#root">root</a>           
   <a href="secref.html#has_parent">has_parent</a>     <a href="secref.html#nchild">nchild</a>         <a href="secref.html#sec">sec</a>            
</pre>
<h2>SYNTAX</h2>
<code><var>section</var> sref = new SectionRef()</code><br>
<h2>DESCRIPTION</h2>
SectionRef keeps a pointer/reference to a section
	The reference is to the currently accessed section at the
	time the object was created.
<p>
	This class allows sections to be referenced as normal object variables
	for assignment and passing as arguments.
<p><hr><p>
<h1><a name="sec">sec</a></h1>
<pre>
<a href="secref.html#SectionRef">SectionRef</a>
</pre>
<h2>SYNTAX</h2>
<code>sref.sec	</code><br>
<h2>DESCRIPTION</h2>
special syntax that makes the reference the currently
		accessed section.
	This class allows sections to be referenced as normal object variables
	for assignment and passing as arguments. The usage is
<a href="secref.hoc">execute following example</a>
<blockquote><pre>
create soma, axon
axon.diam=2
soma.diam=10
access axon
objref s1, s2
soma s1 = new SectionRef()	// s1 holds a reference to the soma
print s1.sec.diam		// print the diameter of the soma
s2 = s1				// s2 also holds a reference to the soma
s2.sec { psection() }		// print all info about soma
axon s2 = new SectionRef()
proc c() {
	$o1.sec connect $o2.sec(0), 1
}
c(s1, s2)
topology()
</pre></blockquote>
This last is a procedure that takes two SectionRef args and
connects them end to end.
<p><hr><p>
<h1><a name="parent">parent</a></h1>
<pre>
<a href="secref.html#SectionRef">SectionRef</a>
</pre>
<h2>SYNTAX</h2>
<code>sref.parent</code><br>
<h2>DESCRIPTION</h2>
parent of sref.sec becomes the currently accessed section. Generally it
is used in a context like <code>sref.parent { statement }</code> just like a
normal section name and does NOT need a section_pop
If there is a chance that a section does not have a parent then
<a href="secref.html#has_parent">has_parent</a> should be called first to avoid an execution error.
Note that the parent is the current parent of sref.sec, not necessarily
the parent when the SectionRef was created.
<p><hr><p>
<h1><a name="trueparent">trueparent</a></h1>
<pre>
<a href="secref.html#SectionRef">SectionRef</a>
</pre>
<h2>SYNTAX</h2>
<code>sref.trueparent</code><br>
<h2>DESCRIPTION</h2>
trueparent of sref.sec becomes the currently accessed section.
This is normally identical to <a href="secref.html#parent">parent</a> except when the
parent's <a href="../nrnoc.html#parent_connection">parent_connection</a> is equal to the parent's
<a href="../nrnoc.html#section_orientation">section_orientation</a> .
If there is a chance that a section does not have a trueparent then
<a href="secref.html#has_trueparent">has_trueparent</a> should be called first to avoid an execution error.
<p><hr><p>
<h1><a name="child">child</a></h1>
<pre>
<a href="secref.html#SectionRef">SectionRef</a>
</pre>
<h2>SYNTAX</h2>
<code>sref.child[i]</code><br>
<h2>DESCRIPTION</h2>
the ith child of sref.sec becomes the currently accessed section.
Generally it
is used in a context like
<blockquote><pre>
for i=0, sref.nchild-1 sref.child[i] { statement }
</pre></blockquote>
Note that the children are the current children of sref.sec, not necessarily
the same as when the SectionRef was created since sections may be
deleted or re-connected subsequent to the instantiation of the SectionRef.
<p><hr><p>
<h1><a name="root">root</a></h1>
<pre>
<a href="secref.html#SectionRef">SectionRef</a>
</pre>
<h2>SYNTAX</h2>
<code>sref.root</code><br>
<h2>DESCRIPTION</h2>
root of sref.sec becomes the currently accessed section.
<p><hr><p>
<h1><a name="has_parent">has_parent</a></h1>
<pre>
<a href="secref.html#SectionRef">SectionRef</a>
</pre>
<h2>SYNTAX</h2>
<code>boolean = sref.has_parent</code><br>
<h2>DESCRIPTION</h2>
returns 1 if sref.sec has a parent and 0 if sref.sec is a root section.
Invoking sref.parent when sref.sec is a root section will print an
error message and halt execution.
<p><hr><p>
<h1><a name="has_trueparent">has_trueparent</a></h1>
<pre>
<a href="secref.html#SectionRef">SectionRef</a>
</pre>
<h2>SYNTAX</h2>
<code>boolean = sref.has_trueparent</code><br>
<h2>DESCRIPTION</h2>
returns 1 if the sref.sec parent node is not the root node and 0 otherwise.
Invoking sref.trueparent when it is the root node will print an
error message and halt execution.
<p><hr><p>
<h1><a name="nchild">nchild</a></h1>
<pre>
<a href="secref.html#SectionRef">SectionRef</a>
</pre>
<h2>SYNTAX</h2>
<code>integer = sref.nchild</code><br>
<h2>DESCRIPTION</h2>
Return the number of child sections connected to sref.sec
<p>
<p><hr><p>
<h1><a name="is_cas">is_cas</a></h1>
<pre>
<a href="secref.html#SectionRef">SectionRef</a>
</pre>
<h2>SYNTAX</h2>
<code>boolean = sref.is_cas()</code><br>
<h2>DESCRIPTION</h2>
Returns 1 if this section reference is the currently accessed section, 0 otherwise.
<p>
<p><hr><p>
<h1><a name="exists">exists</a></h1>
<pre>
<a href="secref.html#SectionRef">SectionRef</a>
</pre>
<h2>SYNTAX</h2>
<code>boolean = sref.exists()</code><br>
<h2>DESCRIPTION</h2>
Returns 1 if the section has not been deleted, 0 otherwise.
<h2>SEE ALSO</h2>
<a href="../topology.html#delete_section">delete_section</a> <a href="../topology.html#section_exists">section_exists</a>
<p>
<p>
<p><hr><p>
<date>
neuron/neuron/classes/secref.hel : Sep 21 09:30
