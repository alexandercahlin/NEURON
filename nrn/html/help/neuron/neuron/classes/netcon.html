<h1><a name="NetCon">NetCon</a></h1>
<pre>
<a href="../../1nrn.html#classes">classes</a>
   <a href="netcon.html#active">active</a>         <a href="netcon.html#postloc">postloc</a>        <a href="netcon.html#record">record</a>         <a href="netcon.html#valid">valid</a>          
   <a href="netcon.html#delay">delay</a>          <a href="netcon.html#pre">pre</a>            <a href="netcon.html#setpost">setpost</a>        <a href="netcon.html#wcnt">wcnt</a>           
   <a href="netcon.html#event">event</a>          <a href="netcon.html#precell">precell</a>        <a href="netcon.html#srcgid">srcgid</a>         <a href="netcon.html#weight">weight</a>         
   <a href="netcon.html#get_recordvec">get_recordvec</a>  <a href="netcon.html#precelllist">precelllist</a>    <a href="netcon.html#syn">syn</a>            <a href="netcon.html#x">x</a>              
   <a href="netcon.html#postcell">postcell</a>       <a href="netcon.html#prelist">prelist</a>        <a href="netcon.html#synlist">synlist</a>        
   <a href="netcon.html#postcelllist">postcelllist</a>   <a href="netcon.html#preloc">preloc</a>         <a href="netcon.html#threshold">threshold</a>      
</pre>
<h2>SYNTAX</h2>
<code>section netcon = new NetCon(&v(x), target)</code><br>
<code>netcon = new NetCon(source, target)</code><br>
<code>section netcon = new NetCon(&v(x), target, threshold, delay, weight)</code><br>
<code>netcon = new NetCon(source, target, threshold, delay, weight)</code><br>
<h2>DESCRIPTION</h2>
Network Connection object that defines a synaptic connection between
a source and target. When the source variable passes threshold in the
positive direction at time t-delay, the target will receive an event
at time t along with weight information. There is no limit on delay
except that it be >= 0 and there is no limit on the number of events
pending delivery.
<p>
If the optional threshold, delay, and weight arguments are not
specified, their default values are 10, 1, and 0 respectively. In
any case, their values can be specified after the netcon has been
constructed, see <a href="netcon.html#threshold">threshold</a> <a href="netcon.html#weight">weight</a> and <a href="netcon.html#delay">delay</a> .
<p>
Note that prior to 12-Jul-2006, when the first form of the constructor
was used, (i.e. a NetCon having a pointer to a source
variable was created, but having no threshold argument) the threshold was
reset to the default 10 (mV) even if the threshold for that source location
had been explicitly set earlier. That behavior caused confusion and has been
changed so that if there is no threshold argument and the threshold location
already exists, the previous threshold is retained.
<p>
The target must be a POINT_PROCESS or ARTIFICIAL_CELL that defines a NET_RECEIVE procedure.
The number of NET_RECEIVE procedure arguments define a weight vector
whose elements can be accessed with through the NetCon.weight ( <a href="netcon.html#weight">weight</a> )variable
but the weight argument in the above constructors specify the value of
the first argument, with the normal interpretation of weight or maximum
conductance. On initialization, all weight elements with index > 0 are
set to 0 unless the NET_RECEIVE block contains an INITIAL block. In the
latter case, that block is executed on a call to <a href="../nrnoc.html#finitialize">finitialize</a> and
allows non-zero initialization of netcon "states" --- args not initialized
in the INITIAL block would be analogous to a <a href="../../nmodl/nmodl.html#Parameter">Parameter</a> except that it
can have a different value for different NetCon instances and can be set
to a desired value with <a href="netcon.html#weight">weight</a> .
<p>
The target is allowed to be nil (NULLObject) in which case the NetCon
is always inactive. However this can be useful for recording (see
<a href="netcon.html#record">record</a> ) the spike train from an output cell.
<p>
The source is normally a reference to a membrane potential which is
watched during simulation for passage past threshold. The
currently accessed section is required by the local variable
time step method in order to determine the source "cell".
Any range variable may be a source variable but I suspect that membrane
potential is the only practical one.
<p>
N.B. For the local variable time step method <a href="cvode.html#use_local_dt">use_local_dt</a> , the
proper currently accessed section for the source must be correct during
the creation of the NetCon so that the proper cell may be associated
with the source. i.e,
<code>netcon = new NetCon(&obj.sec.v(.5), ...)</code>
will not work with the local step method because, although the pointer
is correct, the proper section was popped from the section stack prior
to the constructor call. Instead, the proper syntax is
<code>obj.sec netcon = new NetCon(&v(.5),...)</code>
<p>
The source may also be a PointProcess with a NET_RECEIVE block which
contains a call to net_event. PointProcesses like this serve as entire
artificial cells.
<p>
The source may also
be a PointProcess which contains a "x" variable which is watched for
threshold crossing, but this is obsolete since NET_RECEIVE blocks which
explicitly call net_event are much more efficient since they avoid
the overhead of threshold detection at every time step.
<p>
The source may be a NULLObject. In this case events can only occur by
calling <a href="cvode.html#event">event</a> from hoc. (It is also used by NEOSIM to implement
its own delivery system.)
<p>
A source used by multiple NetCon instances is shared by those instances
to allow faster threshold detection (ie on a per source basis instead
of a per NetCon basis) Therefore, there is really only one threshold
for all NetCon objects that share a source. However, delay and weight
are distinct for each NetCon object.
<p>
The only way one can have multiple threshold values at the same location is
to create a threshold detector point process with a NET_RECEIVE block implemented
with a WATCH statement and calling net_event .
<p>
And I'll say it again:
Note that prior to 12-Jul-2006, when the first form of the constructor
was used, (i.e. a NetCon having a pointer to a source
variable was created, but having no threshold argument) the threshold was
reset to the default 10 (mV) even if the threshold for that source location
had been explicitly set earlier. That behavior caused confusion and has been
changed so that if there is no threshold argument and the threshold location
already exists, the previous threshold is retained.
<p>
From a NetCon instance, various lists of NetCon's can be created
with the same target, precell, or postcell. See <a href="cvode.html#netconlist">netconlist</a>
for creation of NetCon lists from a target, precell, or  postcell
pattern or object.
<p>
<h2>BUGS</h2>
NetCon can currently only be used if a CVode object exists.
<p>
The local variable step method does not work when the source is specified
with the syntax <code>netcon = new NetCon(&soma.v(.5),...)</code>. The
currently accessed section must be correct during the construction of
the object and the above example is correct only during calculation of
the pointer argument.
<p>
<p>
<p><hr><p>
<h1><a name="valid">valid</a></h1>
<pre>
<a href="netcon.html#NetCon">NetCon</a>
</pre>
<h2>SYNTAX</h2>
<code>boolean = netcon.valid()</code><br>
<h2>DESCRIPTION</h2>
Returns 0 if the source or target have been freed. If the NetCon object
is used when it is not valid a runtime error message will be printed on
the console terminal.
<p>
<p><hr><p>
<h1><a name="active">active</a></h1>
<pre>
<a href="netcon.html#NetCon">NetCon</a>
</pre>
<h2>SYNTAX</h2>
<code>boolean = netcon.active(boolean)</code><br>
<code>boolean = netcon.active()</code><br>
<h2>DESCRIPTION</h2>
Turns the synapse on or off in the sense that when off, no events
are delivered using this NetCon instance. Returns the previous
state (or current state if no argument).
<p>
<p><hr><p>
<h1><a name="event">event</a></h1>
<pre>
<a href="netcon.html#NetCon">NetCon</a>
</pre>
<h2>SYNTAX</h2>
<code>netcon.event(tdeliver)</code><br>
<code>netcon.event(tdeliver, flag)</code><br>
<h2>DESCRIPTION</h2>
Delivers an event to the postsynaptic point process at time, tdeliver.
tdeliver must be >= t . Note that the netcon.delay is not used by this
function. Because it is a delivery event as opposed to an initiating
event, it will not be recorded in a NetCon.record(Vector).
<p>
A flag value can only be sent to an ARTIFICIAL_CELL.
<p>
<p><hr><p>
<h1><a name="syn">syn</a></h1>
<pre>
<a href="netcon.html#NetCon">NetCon</a>
</pre>
<h2>SYNTAX</h2>
<code>target_object = netcon.syn()</code><br>
<h2>DESCRIPTION</h2>
Returns a reference to the synaptic target PointProcess.
<p>
<p><hr><p>
<h1><a name="pre">pre</a></h1>
<pre>
<a href="netcon.html#NetCon">NetCon</a>
</pre>
<h2>SYNTAX</h2>
<code>source_object = netcon.pre()</code><br>
<h2>DESCRIPTION</h2>
Returns a reference to the source PointProcess. If the source is a membrane
potential then the return value is NULLobject
<p>
<p><hr><p>
<h1><a name="preloc">preloc</a></h1>
<pre>
<a href="netcon.html#NetCon">NetCon</a>
</pre>
<h2>SYNTAX</h2>
<code>{x = netcon.preloc() ... pop_section()}</code><br>
<h2>DESCRIPTION</h2>
The source section is pushed onto the section stack so that it is
the currently accessed section. Pop_section must be called after you are
finished with the section.
<h2>BUGS</h2>
The return value of x is .5 unless the source is a membrane potential and
located at 0, or 1, in which case value returned is 0 or 1, respectively.
Therefore it does not necessarily correspond to the actual x value location.
If the source was an object, the section is not pushed and the return
value is -1.
<p>
<p><hr><p>
<h1><a name="postloc">postloc</a></h1>
<pre>
<a href="netcon.html#NetCon">NetCon</a>
</pre>
<h2>SYNTAX</h2>
<code>{x = netcon.postloc() ... pop_section()}</code><br>
<h2>DESCRIPTION</h2>
The section of the target point process is pushed onto the section stack
so that it is the currently accessed section. Pop_section must be called
after you are finished with the section. The x return value is the
relative location of the point process in that section.
<p>
<p><hr><p>
<h1><a name="precell">precell</a></h1>
<pre>
<a href="netcon.html#NetCon">NetCon</a>
</pre>
<h2>SYNTAX</h2>
<code>cellobj = netcon.precell()</code><br>
<h2>DESCRIPTION</h2>
If the source is a membrane potential and the section was declared in
an object (defined in a cell template), a reference to the presynaptic cell
(object) is returned.
<p>
<p><hr><p>
<h1><a name="postcell">postcell</a></h1>
<pre>
<a href="netcon.html#NetCon">NetCon</a>
</pre>
<h2>SYNTAX</h2>
<code>cellobj = netcon.postcell()</code><br>
<h2>DESCRIPTION</h2>
If the synaptic point process is located in a section which was declared in
an object (defined in a cell template), a reference to the postsynaptic cell
(object) is returned.
<p>
<p><hr><p>
<h1><a name="setpost">setpost</a></h1>
<pre>
<a href="netcon.html#NetCon">NetCon</a>
</pre>
<h2>SYNTAX</h2>
<code>netcon.setpost(newtarget)</code><br>
<h2>DESCRIPTION</h2>
Will change the old postsynaptic POINT_PROCESS target to the one specified
by the newtarget. If there is no argument
or the argument is NullObject then NetCon will have no target and the
active flag will be set to 0. Note that a target change will preserve the
current weight vector only if the new and old targets have the same
weight vector size (number of arguments in the NET_RECEIVE block).
<p>
<p><hr><p>
<h1><a name="prelist">prelist</a></h1>
<pre>
<a href="netcon.html#NetCon">NetCon</a>
</pre>
<h2>SYNTAX</h2>
<code>List = netcon.prelist()</code><br>
<code>List = netcon.prelist(List)</code><br>
<h2>DESCRIPTION</h2>
List of all the NetCon objects with source the same as netcon.
With no argument, a new List is created.
If the List arg is present, the objects are appended.
<p>
<p><hr><p>
<h1><a name="synlist">synlist</a></h1>
<pre>
<a href="netcon.html#NetCon">NetCon</a>
</pre>
<h2>SYNTAX</h2>
<code>List = netcon.synlist()</code><br>
<code>List = netcon.synlist(List)</code><br>
<h2>DESCRIPTION</h2>
List of all the NetCon objects with target the same as netcon.
With no argument, a new List is created.
If the List arg is present, the objects are appended.
<h2>SEE ALSO</h2>
<a href="cvode.html#netconlist">netconlist</a>
<p>
<p><hr><p>
<h1><a name="postcelllist">postcelllist</a></h1>
<pre>
<a href="netcon.html#NetCon">NetCon</a>
</pre>
<h2>SYNTAX</h2>
<code>List = netcon.postcelllist()</code><br>
<code>List = netcon.postcelllist(List)</code><br>
<h2>DESCRIPTION</h2>
List of all the NetCon objects with postsynaptic cell object the same as netcon.
With no argument, a new List is created.
If the List arg is present, the objects are appended.
<h2>SEE ALSO</h2>
<a href="cvode.html#netconlist">netconlist</a>
<p>
<p><hr><p>
<h1><a name="precelllist">precelllist</a></h1>
<pre>
<a href="netcon.html#NetCon">NetCon</a>
</pre>
<h2>SYNTAX</h2>
<code>List = netcon.precelllist()</code><br>
<code>List = netcon.precelllist(List)</code><br>
<h2>DESCRIPTION</h2>
List of all the NetCon objects with presynaptic cell object the same as netcon.
With no argument, a new List is created.
If the List arg is present, the objects are appended.
<h2>SEE ALSO</h2>
<a href="cvode.html#netconlist">netconlist</a>
<p>
<p><hr><p>
<h1><a name="delay">delay</a></h1>
<pre>
<a href="netcon.html#NetCon">NetCon</a>
</pre>
<h2>SYNTAX</h2>
<code>del = netcon.delay</code><br>
<code>netcon.delay = del</code><br>
<h2>DESCRIPTION</h2>
Time (ms) between source crossing threshold and delivery of event
to target. Any number of threshold events may occur before delivery of
previous events. delay may be any value >= 0.
<p>
<p><hr><p>
<h1><a name="wcnt">wcnt</a></h1>
<pre>
<a href="netcon.html#NetCon">NetCon</a>
</pre>
<h2>SYNTAX</h2>
<code>n = netcon.wcnt()</code><br>
<h2>DESCRIPTION</h2>
Returns the size of the weight array.
<p>
<p><hr><p>
<h1><a name="weight">weight</a></h1>
<pre>
<a href="netcon.html#NetCon">NetCon</a>
</pre>
<h2>SYNTAX</h2>
<code>w = netcon.weight</code><br>
<code>netcon.weight = w</code><br>
<code>x = netcon.weight[i]</code><br>
<code>netcon.weight[i] = x</code><br>
<h2>DESCRIPTION</h2>
Weight variable which is delivered to the target point processes
NET_RECEIVE procedure. The number of arguments in the model descriptions
NET_RECEIVE procedure determines the size of the weight vector.
Generally the 0th element (no index required) refers to synaptic weight
and remaining elements are used as storage by a synaptic model for purposes
of distinguishing NetCon streams of events. However if the NET_RECEIVE
block of the post synaptic point process contains an INITIAL block,
that block is executed instead of setting all weight[i>0] = 0.
<p>
<p><hr><p>
<h1><a name="threshold">threshold</a></h1>
<pre>
<a href="netcon.html#NetCon">NetCon</a>
</pre>
<h2>SYNTAX</h2>
<code>th = netcon.threshold</code><br>
<code>netcon.threshold = th</code><br>
<h2>DESCRIPTION</h2>
Source threshold. Note that many NetCon objects may share the same
source.
<p>
Note that prior to 12-Jul-2006, when a NecCon was constructed with no threshold
argument, the threshold was
reset to the default 10 (mV) even if the threshold for that source location
had been explicitly set earlier. That behavior caused confusion and has been
changed so that if the constructor has no threshold argument and the
threshold location already exists, the previous threshold is retained.
<p>
<p>
<p><hr><p>
<h1><a name="x">x</a></h1>
<pre>
<a href="netcon.html#NetCon">NetCon</a>
</pre>
<h2>SYNTAX</h2>
<code>x = netcon.x</code><br>
<code>netcon.x = x</code><br>
<h2>DESCRIPTION</h2>
Value of the source variable which is watched for threshold crossing.
If the source is a membrane potential then netcon.x is a reference to
that potential. If the source is an object, then netcon.x is a reference
to the objects field called "x", ie source.x .
<p>
<p><hr><p>
<h1><a name="record">record</a></h1>
<pre>
<a href="netcon.html#NetCon">NetCon</a>
</pre>
<h2>SYNTAX</h2>
<code>netcon.record(Vector)</code><br>
<code>netcon.record()</code><br>
<code>netcon.record("stmt")</code><br>
<code>netcon.record(tvec, idvec)</code><br>
<code>netcon.record(tvec, idvec, id)</code><br>
<h2>DESCRIPTION</h2>
Records the event times at the source the netcon connects to.
<p>
With no argument, no vector recording at the source takes place.
<p>
The vector is resized to 0 when <a href="../nrnoc.html#finitialize">finitialize</a> is called.
<p>
NB: Recording takes place on a per source, not a per netcon basis,
and the source only records into one vector at a time.
<p>
When the argument is a "stmt", then the statement is called on a
source event. Like the Vector case, the source only manages
one statement at a time. The stmt is removed when the arg is "".
<p>
If a source is recording a vector, that source is not destroyed when
the last netcon connecting to it is destroyed and it continues to record.
The source is notified when the vector it is recording
ceases to exist---at that time it will be destroyed if no netcons currently
connect to it. To do a recording of a source, the following idiom
works:
<blockquote><pre>
objref vec, netcon, nil
vec = new Vector()
netcon = new NetCon(source, nil)
netcon.record(vec)
objref netcon
</pre></blockquote>
The source will continue to record events until record is called
with another netcon connecting to the source or until the vec is
destroyed. Notice that this idiom allows recording from output cells
(which normally have no connecting netcons) as well as simplifying the
management of recording from cells.
<p>
Note that NetCon.event(t) events are NOT recorded.
<p>
The netcon.record(tvec, idvec) form is similar to netcon.record(tvec) but
in addition the id value of NetCon[id] is also recorded in idvec (or the
specified id integer if the third arg is present). This allows
many source recordings with a single pair of vectors and obviates the use
of separate tvec objects for each recording.
<h2>EXAMPLES</h2>
To stop the simulation when a particular compartment reaches a threshold.
<a href="ev.hoc">execute following example</a>
<blockquote><pre>
// ... soma with hh, IClamp, and voltage plot ...

objref nc, nil
soma nc = new NetCon(&amp;v(.5), nil)
nc.threshold = 0 // watch out! only one threshold per presyn location
nc.record("handle()")

proc handle() {
	print "called handle() at time ", t, " when soma.v(.5) = ", soma.v(.5)
	stoprun = 1 // Will stop but may go one extra step. Also with
		// local step the cells will be at different times.
		// So may wish to do a further...
	cvode.event(t+1e-6) 
}

cvode_active(1) // optional. but fixed step will probably do one extra time step
cvode.condition_order(2) // optional. but much more accurate event time evaluation.

run()
print "after run(), t = ", t, " and soma.v(.5) = ", soma.v(.5)
</pre></blockquote>
<p>
<p><hr><p>
<h1><a name="get_recordvec">get_recordvec</a></h1>
<pre>
<a href="netcon.html#NetCon">NetCon</a>
</pre>
<h2>SYNTAX</h2>
<code>tvec = netcon.get_recordvec()</code><br>
<h2>DESCRIPTION</h2>
Returns the Vector being recorded by the netcon. If the NetCon is not
recording or is recording via a hoc statement, the return value is
NULLobject. Note that record vector is also returned if the NetCon is one of
many recording into the same Vector via the NetCon.record(tvec, idvec)
style.
<p>
<p><hr><p>
<h1><a name="srcgid">srcgid</a></h1>
<pre>
<a href="netcon.html#NetCon">NetCon</a>
</pre>
<h2>SYNTAX</h2>
<code>gid = netcon.srcgid()</code><br>
<h2>DESCRIPTION</h2>
Returns the global source id integer that sends events through the NetCon.
May return -1 or -2 if the NetCon has no source or if the source does not
send interprocessor events. If the gid >= 0 then the netcon must have been
created by a <a href="parcon.html#gid_connect">gid_connect</a> call with gid as the first
arg or else it is connected to spike detector that was associated with a
gid via <a href="parcon.html#cell">cell</a> .
<p>
There is no way to determine the corresponding target cell gid (assuming there
is one and only one gid source integer for each cell. But see
<a href="netcon.html#syn">syn</a> and <a href="netcon.html#postcell">postcell</a> .
<p>
<p>
<p><hr><p>
<date>
neuron/neuron/classes/netcon.hel : Sep 21 09:30
