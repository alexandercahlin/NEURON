<p>
<h1><a name="Python">Python</a></h1>
<pre>
<a href="../../1nrn.html#classes">classes</a>
   <a href="python.html#Hoc_accessing_Python">Hoc_accessing_Python</a>  <a href="python.html#Installation">Installation</a>  <a href="python.html#Python_accessing_Hoc">Python_accessing_Hoc</a>  
</pre>
<p>
<p><hr><p>
<h1><a name="Installation">Installation</a></h1>
<pre>
<a href="python.html#Python">Python</a>
</pre>
<h2>SYNTAX</h2>
<code>./configure --with-nrnpython ...</code><br>
<code>make</code><br>
<code>make install</code><br>
<h2>DESCRIPTION</h2>
Builds NEURON with Python embedded as an alternative interpreter to HOC.
The python version used is that found from <code>which python</code>.
<p>
NEURON can be used as an extension to Python if, after building as above,
one goes to the src/nrnpython directory containing the Makefile and types
something analogous to
<blockquote><pre>
python setup.py install --home=$HOME
</pre></blockquote>
Which on my machine installs in /home/hines/lib64/python/neuron
and can be imported into NEURON with
<blockquote><pre>
ipython
import sys
sys.path.append("/home/hines/lib64/python")
import neuron
</pre></blockquote>
It is probably better to avoid the incessant <code>import sys...</code> and instead
add to your shell environment something analogous to
<blockquote><pre>
export PYTHONPATH=$PYTHONPATH:/home/hines/lib64/python
</pre></blockquote>
since when launching NEURON and embedding Python, the path is automatically
defined so that <code>import neuron</code> does not require any prerequisites.
If there is a <code>&lt;host-cpu&gt;/.libs/libnrnmech.so</code> file in your working
directory, those nmodl mechanisms will be loaded as well.
After this, you will probably want to:
<blockquote><pre>
h = neuron.h # neuron imports hoc and does a  h = hoc.HocObject()
</pre></blockquote>
In the past we also recommended an "import nrn" but this is no longer
necessary as everything in that module is also directly available from
the "h" object.
You can use the hoc function <a href="../../general/function/system.html#nrn_load_dll">nrn_load_dll</a> to load mechanism files
as well, e.g. if neurondemo was used earlier so the shared object exists,
<blockquote><pre>
h = hoc.HocObject()
h('nrn_load_dll("$(NEURONHOME)/demo/release/x86_64/.libs/libnrnmech.so")')
</pre></blockquote>
<p>
<p><hr><p>
<h1><a name="Python_accessing_Hoc">Python_accessing_Hoc</a></h1>
<pre>
<a href="python.html#Python">Python</a>
   <a href="python.html#HocObject">HocObject</a>      <a href="python.html#Section">Section</a>        <a href="python.html#cas">cas</a>            <a href="python.html#hoc_ac">hoc_ac</a>         
   <a href="python.html#Mechanism">Mechanism</a>      <a href="python.html#Segment">Segment</a>        <a href="python.html#execute">execute</a>        
</pre>
<h2>SYNTAX</h2>
<code>nrniv -python [file.hoc file.py  -c "python_statement"]</code><br>
<code>nrngui -python ...</code><br>
<code>neurondemo -python ...</code><br>
<h2>DESCRIPTION</h2>
Launches NEURON with Python as the command line interpreter.
File arguments with a .hoc suffix are interpreted using the
Hoc interpreter. File arguments with the .py suffix are interpreted
using the Python interpreter. The -c statement causes python to
execute the statement.
The import statements allow use of the following
<p>
<p><hr><p>
<h1><a name="execute">execute</a></h1>
<pre>
<a href="python.html#Python_accessing_Hoc">Python_accessing_Hoc</a>
</pre>
<h2>SYNTAX</h2>
<code>import neuron</code><br>
<code>neuron.hoc.execute('any hoc statement')</code><br>
<h2>DESCRIPTION</h2>
Execute any statement or expression using the Hoc interpreter. This is
obsolete since the same thing can be accomplished with HocObject with
less typing.
Note that triple quotes can be used for multiple line statements.
A '\n' should be escaped as '\\n'.
<blockquote><pre>
hoc.execute('load_file("nrngui.hoc")')
</pre></blockquote>
<h2>SEE ALSO</h2>
<a href="python.html#nrnpython">nrnpython</a>
<p>
<p><hr><p>
<h1><a name="HocObject">HocObject</a></h1>
<pre>
<a href="python.html#Python_accessing_Hoc">Python_accessing_Hoc</a>
</pre>
<h2>SYNTAX</h2>
<code>import neuron</code><br>
<code>h = neuron.hoc.HocObject()</code><br>
<h2>DESCRIPTION</h2>
Allow access to anything in the Hoc interpreter.
Note that <code>h = neuron.h</code> is the typical statement used since the
neuron module creates an h field.
When created via hoc.HocObject() its print string is "TopLevelHocInterpreter".
<blockquote><pre>
h("any hoc statement")
</pre></blockquote>
is the same as hoc.execute(...)
<p>
Any hoc variable or string in the Hoc world can be accessed
in the Python world:
<blockquote><pre>
h('strdef s')
h('{x = 3  s = "hello"}')
print h.x          # prints 3.0
print h.s          # prints hello
</pre></blockquote>
And if it is assigned a value in the python world it will be that value
in the Hoc world. (Note that any numeric python type becomes a double
in Hoc.)
<blockquote><pre>
h.x = 25
h.s = 'goodbye'
h('print x, s')    #prints 25 goodbye
</pre></blockquote>
<p>
Any hoc object can be handled in Python.
<blockquote><pre>
h('objref vec')
h('vec = new Vector(5)')
print h.vec        # prints Vector[0]
print h.vec.size() # prints 5.0
</pre></blockquote>
Note that any hoc object method or field may be called, or evaluated/assigned
using the normal dot notation which is consistent between hoc and python.
However, hoc object methods MUST have the parentheses or else the Python
object is not the return value of the method but a method object. ie.
<blockquote><pre>
x = h.vec.size     # not 5 but a python callable object
print x            # prints: Vector[0].size()
print x()          # prints 5.0
</pre></blockquote>
This is also true for indices
<blockquote><pre>
h.vec.indgen().add(10) # fills elements with 10, 11, ..., 14
print h.vec.x[2]   # prints 12.0
x = h.vec.x        # a python indexable object
print x            # prints Vector[0].x[?]
print x[2]         # prints 12.0
</pre></blockquote>
The hoc object can be created directly in Python. E.g.
<blockquote><pre>
v = h.Vector(10).indgen.add(10)
</pre></blockquote>
<p>
Iteration over hoc Vector, List, and arrays is supported. e.g.
<blockquote><pre>
v = h.Vector(4).indgen().add(10)
for x in v :
  print x

l = h.List() ; l.append(v); l.append(v); l.append(v)
for x in l :
  print x

h('objref o[2][3]')
for x in h.o :
  for y in x :
    print x, y

</pre></blockquote>
<p>
Any hoc Section can be handled in Python. E.g.
<blockquote><pre>
h('create soma, axon')
ax = h.axon
</pre></blockquote>
makes ax a Python <a href="python.html#Section">Section</a> which references the hoc
axon section. Many hoc functions require a currently accessed section
and for these a typical idiom is
<blockquote><pre>
ax.push() ; print secname() ; h.pop_section()
</pre></blockquote>
More compact is to use the "sec" keyword parameter after the last positional
parameter which makes the Section value the currently accessed section during
the scope of the function call. e.g
<blockquote><pre>
print secname(sec=ax)
</pre></blockquote>
<p>
Point processes are handled by direct object creation as in
<blockquote><pre>
stim = IClamp(1.0, sec = ax)
// or
stim = IClamp(ax(1.0))
</pre></blockquote>
The latter is a somewhat simpler idiom that uses the Segment object which knows both the
section and the location in the section and can also be used with the
stim.loc function.
<p>
Many hoc functions use call by reference and return information by
changing the value of an argument. These are called from the python
world by passing a HocObject.ref() object. Here is an example that
changes a string.
<blockquote><pre>
h('proc chgstr() { $s1 = "goodbye" }')
s = h.ref('hello')
print s[0]          # notice the index to dereference. prints hello
h.chgstr(s)
print s[0]          # prints goodbye
h.sprint(s, 'value is %d', 2+2)
print s[0]          # prints value is 4
</pre></blockquote>
and here is an example that changes a pointer to a double
<blockquote><pre>
h('proc chgval() { $&amp;1 = $2 }')
x = h.ref(5)
print x[0]          # prints 5.0
h.chgval(x, 1+1)
print x[0]          # prints 2.0
</pre></blockquote>
Finally, here is an example that changes a objref arg.
<blockquote><pre>
h('proc chgobj() { $o1 = new List() }')
v = h.ref([1,2,3])  # references a Python object
print v[0]          # prints [1, 2, 3]
h.chgobj(v)
print v[0]          # prints List[0]
</pre></blockquote>
Unfortunately, the HocObject.ref() is not often useful since it is not really
a pointer to a variable. For example consider
<blockquote><pre>
h('x = 1')
y = h.ref(h.x)
print y         # prints hoc ref value 1
print h.x, y[0] # prints 1.0 1.0
h.x = 2
print h.x, y[0] # prints 2.0 1.0
</pre></blockquote>
and thus in not what is needed in the most common
case of a hoc function holding a pointer to a variable such as
Vector.record or Vector.play. For this one needs the _ref_varname idiom
which works for any hoc variable and acts exactly like a c pointer. eg:
<blockquote><pre>
h('x = 1')
y = h._ref_x
print y          # prints pointer to hoc value 1
print h.x, y[0]  # prints 1.0 1.0
h.x = 2
print h.x, y[0]  # prints 2.0 2.0
y[0] = 3
print h.x, y[0]  # prints 3.0 3.0
</pre></blockquote>
Of course, this works only for hoc variables, not python variables.  For
arrays, use all the index arguments and prefix the name with _ref_.  The
pointer will be to the location indexed and one may access any element
beyond the location by giving one more non-negative index.  No checking
is done with regard to array bounds errors.  e.g
<blockquote><pre>
v = h.Vector(4).indgen().add(10)
y = v._ref_x[1]    # holds pointer to second element of v
print v.x[2], y[1] # prints 12.0 12.0
y[1] = 50
v.printf()         # prints 10 11 50 13
</pre></blockquote>
The idiom is used to record from (or play into) voltage and mechanism variables. eg
<blockquote><pre>
v = h.Vector()
v.record(h.soma(.5)._ref_v, sec = h.soma)
pi = h.Vector()
pi.record(h.soma(.5).pas._ref_i, sec = h.soma)
ip = h.Vector()
ip.record(h.soma(.5)._ref_i_pas, sec = h.soma)
</pre></blockquote>
<p>
The factory idiom is one way to create Hoc objects and use them
in Python.
<blockquote><pre>
h('obfunc newvec() { return new Vector($1) }')
v = h.newvec(10).indgen().add(10)
v.printf()          # prints 10 11 ... 19 (not 10.0 ... since printf is a hoc function)
</pre></blockquote>
but that idiom is more or less obsolete as the same thing can be accomplished
directly as shown a few fragments back. Also consider the minimalist
<blockquote><pre>
vt = h.Vector
v = vt(4).indgen().add(10)
</pre></blockquote>
Any Python object can be stored in a Hoc List. It is more efficient
when navigating the List to use a python callable that avoids repeated
lookup of a Hoc method symbol. Note that in the Hoc world a python object
is of type PythonObject but python strings and scalars are translated back
and forth as strdef and scalar doubles respectively.
<blockquote><pre>
h('obfunc newlist() { return new List() }')
list = h.newlist()
apnd = list.append
apnd([1,2,3])      # Python list in hoc List
apnd(('a', 'b', 'c')) # Python tuple in hoc List
apnd({'a':1, 'b':2, 'c':3}) # Python dictionary in hoc List
item = list.object
for i in range(0, int(list.count())) : # notice the irksome cast to int.
  print item(i)

h('for i=0, List[0].count-1 print List[0].object(i)')
</pre></blockquote>
<p>
To see all the methods available for a hoc object, use, for example,
<blockquote><pre>
dir(h.Vector)
</pre></blockquote>
<p>
h.anyclass can be subclassed with
<blockquote><pre>
class MyVector(neuron.hclass(neuron.h.Vector)) :
  pass
v = MyVector(10)
v.zzz = 'hello' # a new attribute
print v.size() # call any base method
</pre></blockquote>
If you override a base method such as 'size' use
<blockquote><pre>
v.baseattr('size')()
</pre></blockquote>
to access the base method. Multiple inheritance involving hoc classes
probably does not make sense.
If you override the __init__ procedure when subclassing a Section,
be sure to explicitly
initialize the Section part of the instance with
<blockquote><pre>
nrn.Section.__init__()
</pre></blockquote>
<p>
Since nrn.Section is a standard Python class one can
subclass it normally with
<blockquote><pre>
class MySection(neuron.nrn.Section):
  pass
</pre></blockquote>
<p>
The hoc setpointer statement is effected in Python as a function call
with a syntax for POINT_PROCESS and SUFFIX (density)mechanisms respectively
of
<blockquote><pre>
h.setpointer(_ref_hocvar, 'POINTER_name', point_proces_object)
h.setpointer(_ref_hocvar, 'POINTER_name', nrn.Mechanism_object)
</pre></blockquote>
See nrn/share/examples/nrniv/nmodl/(tstpnt1.py and tstpnt2.py) for
examples of usage. For a density mechanism, the 'POINTER_name' cannot
have the SUFFIX appended. For example if a mechanism with suffix foo has
a POINTER bar and you want it to point to t use
<blockquote><pre>
h.setpointer(_ref_t, 'bar', sec(x).foo)
</pre></blockquote>
<p>
<h2>SEE ALSO</h2>
<a href="../../general/classes/vector/vect.html#to_python">to_python</a> <a href="../../general/classes/vector/vect.html#from_python">from_python</a>
<p>
<p><hr><p>
<h1><a name="hoc_ac">hoc_ac</a></h1>
<pre>
<a href="python.html#Python_accessing_Hoc">Python_accessing_Hoc</a>
</pre>
<h2>SYNTAX</h2>
<code>import hoc</code><br>
<code>double_value = hoc.hoc_ac()</code><br>
<code>hoc.hoc_ac(double_value)</code><br>
<h2>DESCRIPTION</h2>
Get and set the hoc global scalar, <a href="../../general/predec.html#hoc_ac_">hoc_ac_</a>
This is obsolete since HocObject
is far more general.
<blockquote><pre>
import hoc
hoc.hoc_ac(25)
hoc.execute('print hoc_ac_') # prints 25
hoc.execute('hoc_ac_ = 17')
print hoc.hoc_ac()  # prints 17
</pre></blockquote>
<p>
<p><hr><p>
<h1><a name="cas">cas</a></h1>
<pre>
<a href="python.html#Python_accessing_Hoc">Python_accessing_Hoc</a>
</pre>
<h2>SYNTAX</h2>
<code>sec = h.cas()</code><br>
<code>or</code><br>
<code>import nrn</code><br>
<code>sec = nrn.cas()</code><br>
<h2>DESCRIPTION</h2>
Returns the <a href="../secspec.html#CurrentlyAccessedSection">CurrentlyAccessedSection</a> as a Python
<a href="python.html#Section">Section</a> object.
<blockquote><pre>
import neuron
neuron.h('''
  create soma, dend[3], axon
  access dend[1]
''')

sec = h.cas()
print sec, sec.name()
</pre></blockquote>
<p>
<p><hr><p>
<h1><a name="Section">Section</a></h1>
<pre>
<a href="python.html#Python_accessing_Hoc">Python_accessing_Hoc</a>
</pre>
<h2>SYNTAX</h2>
<code>sec = h.Section()</code><br>
<code>sec = h.Section([name='string', [cell=self])</code><br>
<code>or</code><br>
<code>import nrn</code><br>
<code>sec = nrn.Section()</code><br>
<h2>DESCRIPTION</h2>
The Python Section object allows modification and evaluation of the
information associated with a NEURON <a href="../../agui/pltshape.html#Section">Section</a> The typical way to get
a reference to a Section in Python is with <a href="python.html#cas">cas</a> or
by using the hoc section name as in <code>asec = h.dend[4]</code>.
The <code>sec = Section()</code> will create an anonymous Section with a hoc name
constructed from "Section" and the Python reference address.
Access to Section variables is through standard dot notation.
The "anonymous" python section can be given a name with the named
parameter and/or associated with a cell object using the named cell parameter.
Note that a cell association is required if one anticipates using the
<a href="parcon.html#gid2cell">gid2cell</a> method of <a href="parcon.html#ParallelContext">ParallelContext</a> .
<blockquote><pre>
import neuron
h = neuron.h
sec = h.Section()
print sec        # prints &lt;nrn.Section object at 0x2a96982108&gt;
print sec.name() # prints PySec_2a96982108
sec.nseg = 3     # section has 3 segments (compartments)
sec.insert("hh") # all compartments have the hh mechanism
sec.L = 20       # Length of the entire section is 20 um.
for seg in sec :   # iterates over the section compartments
  for mech in seg : # iterates over the segment mechanisms
    print sec.name(), seg.x, mech.name()
</pre></blockquote>
A Python Section can be made the currently accessed
section by using its push method. Be sure to use <a href="../secspec.html#pop_section">pop_section</a>
when done with it to restore the previous currently accessed section.
I.e, given the above fragment,
<blockquote><pre>
from neuron import h
h('''
objref p
p = new PythonObject()
{p.sec.push() psection() pop_section()}
''')
#or
sec.push()
h.secname()
h.psection()
h.pop_section()
</pre></blockquote>
When calling a hoc function it is generally preferred to named sec arg style
to automatically push and pop the section stack during the scope of the
hoc function. ie
<blockquote><pre>
h.psection(sec=sec)
</pre></blockquote>
<p>
With a <a href="secref.html#SectionRef">SectionRef</a> one can, for example,
<blockquote><pre>
h.dend[2].push() ; sr = h.SectionRef() ; h.pop_section()
sr.root.push() ; print h.secname() ; h.pop_section()
</pre></blockquote>
or, more compactly,
sr = h.SectionRef(sec=h.dend[2])
print sr.root.name(), h.secname(sec=sr.root)
</pre></blockquote>
<p>
Iteration over sections is accomplished with
<blockquote><pre>
for s in h.allsec() :
  print h.secname()

sl = h.SectionList() ; sl.wholetree()
for s in sl :
  print h.secname()
</pre></blockquote>
<p>
Connecting a child section to a parent section uses the connect method
using either
<blockquote><pre>
childsec.connect(parentsec, parentx, childx)
childsec.connect(parentsegment, childx)
</pre></blockquote>
In the first form parentx and childx are optional with default values of
1 and 0 respectively. Parentx must be 0 or 1. In the second form, childx
is optional and by default is 0. The parentsegment must be either
parentsec(0) or parentsec(1).
<p>
sec.cell() returns the cell object that 'owns' the section. The return
value is None if no object owns the section (a top level section), the
instance of the hoc template that created the section, or the python
object specified by the named cell parameter
when the python section was created.
<p>
<p><hr><p>
<h1><a name="Segment">Segment</a></h1>
<pre>
<a href="python.html#Python_accessing_Hoc">Python_accessing_Hoc</a>
</pre>
<h2>SYNTAX</h2>
<code>seg = section(x)</code><br>
<h2>DESCRIPTION</h2>
A Segment object is obtained from a Section with the function notation where
the argument is 0 <= x <= 1 an the segment is the compartment that contains
the location x. The x value of the segment is seg.x and the section is
seg.sec . From a Segment one can obtain a Mechanism.
<p>
<p><hr><p>
<h1><a name="Mechanism">Mechanism</a></h1>
<pre>
<a href="python.html#Python_accessing_Hoc">Python_accessing_Hoc</a>
</pre>
<h2>SYNTAX</h2>
<code>mech = segment.mechname</code><br>
<h2>DESCRIPTION</h2>
A Mechanism object is obtained from a Segment. From a Mechanism one can
obtain a range variable. The range variable can also be obtained from the
segment by using the hoc range variable name that has the mechanism suffix.
<p>
<p><hr><p>
<h1><a name="Hoc_accessing_Python">Hoc_accessing_Python</a></h1>
<pre>
<a href="python.html#Python">Python</a>
   <a href="python.html#PythonObject">PythonObject</a>   <a href="python.html#nrnpython">nrnpython</a>      
</pre>
<h2>SYNTAX</h2>
<code>nrniv [file.hoc...]</code><br>
<h2>DESCRIPTION</h2>
The absence of a -python argument causes NEURON to launch with Hoc
as the command line interpreter. At present, no file.py arguments
are allowed as all named files are treated as hoc files. Nevertheless,
from the hoc world any python statement can be executed and anything
in the python world can be assigned or evaluated.
<p><hr><p>
<h1><a name="nrnpython">nrnpython</a></h1>
<pre>
<a href="python.html#Hoc_accessing_Python">Hoc_accessing_Python</a>
</pre>
<h2>SYNTAX</h2>
<code>nrnpython("any python statement")</code><br>
<h2>DESCRIPTION</h2>
Executes any python statement.
<blockquote><pre>
nrnpython("import sys")
nrnpython("print sys.path")
nrnpython("a = [1,2,3]")
nrnpython("print a")
nrnpython("import hoc")
nrnpython("hoc.execute('print PI')")
</pre></blockquote>
<p>
<p><hr><p>
<h1><a name="PythonObject">PythonObject</a></h1>
<pre>
<a href="python.html#Hoc_accessing_Python">Hoc_accessing_Python</a>
</pre>
<h2>SYNTAX</h2>
<code>p = new PythonObject()</code><br>
<h2>DESCRIPTION</h2>
Accesses any python object. Almost equivalent to <a href="python.html#HocObject">HocObject</a> in the
python world but because of some hoc syntax limitations, ie. hoc does not
allow an object to be a callable function, and top level indices have
different semantics, we sometimes need to use a special idiom, ie. the '_'
method. Strings and double numbers move back and forth between Python and
Hoc (but Python integers, etc. become double values in Hoc, and when they
get back to the Python world, they are doubles).
<p>
<blockquote><pre>
objref p
p = new PythonObject()
nrnpython("ev = lambda arg : eval(arg)") // interprets the string arg as an
                          //expression and returns the value
objref tup
print p.ev("3 + 4")       // prints 7
print p.ev("'hello' + 'world'") // prints helloworld
tup = p.ev("('xyz',2,3)") // tup is a PythonObject wrapping a Python tuple
print tup                 // prints PythonObject[1]
print tup._[2]            // the 2th tuple element is 3
print tup._[0]            // the 0th tuple element is xyz

nrnpython("import hoc")   // back in the Python world
nrnpython("h = hoc.HocObject()") // tup is a Python Tuple object
nrnpython("print h.tup")   // prints ('xyz', 2, 3)
</pre></blockquote>
Note that one needs the '_' method, equivalent to 'this', because trying to
get at an element through the built-in python method name via
<blockquote><pre>
tup.__getitem__(0)
</pre></blockquote>
gives the error "TypeError: tuple indices must be integers" since
the Hoc 0 argument is a double 0.0 when it gets into Python.
It is difficult to pass an integer to a Python function from the hoc world.
The only time Hoc doubles appear as integers in Python, is when they are
the value of an index. If the index is not an integer, e.g. a string, use
the __getitem__ idiom.
<blockquote><pre>
objref p
p = new PythonObject()
nrnpython("ev = lambda arg : eval(arg)")
objref d
d = p.ev("{'one':1, 'two':2, 'three':3}")
print d.__getitem__("two")        // prints 2

objref dg
dg = d.__getitem__
print dg._("two")                // prints 2
</pre></blockquote>
<p>
To assign a value to a python variable that exists in a module use
<blockquote><pre>
nrnpython("a = 10")
p = new PythonObject()
p.a = 25
p.a = "hello"
p.a = new Vector(4)
nrnpython("b = []")
p.a = p.b
</pre></blockquote>
<p>
<p><hr><p>
<date>
neuron/neuron/classes/python.hel : Sep 21 09:30
