<p>
<h1><a name="functions">functions</a></h1>
<pre>
<a href="../1nrn.html#neuron">neuron</a>
   <a href="nrnoc.html#attr_praxis">attr_praxis</a>    <a href="nrnoc.html#fit_praxis">fit_praxis</a>     <a href="function/nfunc.html#nrnglobalmechmenu">nrnglobalmechmenu</a>  <a href="nrnoc.html#pval_praxis">pval_praxis</a>  
   <a href="nrnoc.html#batch_run">batch_run</a>      <a href="nrnoc.html#fmatrix">fmatrix</a>        <a href="function/nfunc.html#nrnmechmenu">nrnmechmenu</a>    <a href="nrnoc.html#secname">secname</a>        
   <a href="nrnoc.html#batch_save">batch_save</a>     <a href="nrnoc.html#frecord_init">frecord_init</a>   <a href="function/nfunc.html#nrnpointmenu">nrnpointmenu</a>   <a href="nrnoc.html#section_orientation">section_orientation</a>  
   <a href="nrnoc.html#fadvance">fadvance</a>       <a href="nrnoc.html#fstim">fstim</a>          <a href="function/nfunc.html#nrnsecmenu">nrnsecmenu</a>     <a href="nrnoc.html#sectionname">sectionname</a>    
   <a href="nrnoc.html#fclamp">fclamp</a>         <a href="nrnoc.html#fstimi">fstimi</a>         <a href="nrnoc.html#parent_connection">parent_connection</a>  <a href="nrnoc.html#stop_praxis">stop_praxis</a>  
   <a href="nrnoc.html#fclampi">fclampi</a>        <a href="function/hocmech.html#hocmech">hocmech</a>        <a href="nrnoc.html#parent_node">parent_node</a>    <a href="nrnoc.html#this_node">this_node</a>      
   <a href="nrnoc.html#fclampv">fclampv</a>        <a href="nrnoc.html#initnrn">initnrn</a>        <a href="nrnoc.html#parent_section">parent_section</a>  <a href="nrnoc.html#this_section">this_section</a>  
   <a href="nrnoc.html#fcurrent">fcurrent</a>       <a href="nrnoc.html#ismembrane">ismembrane</a>     <a href="nrnoc.html#prstim">prstim</a>         
   <a href="nrnoc.html#finitialize">finitialize</a>    <a href="nrnoc.html#issection">issection</a>      <a href="nrnoc.html#psection">psection</a>       
</pre>
These are Neuron-specific functions which you can call from 
the nrnoc interpreter.
<p>
<p><hr><p>
<h1><a name="batch_run">batch_run</a></h1>
<pre>
<a href="nrnoc.html#functions">functions</a>
</pre>
<h2>SYNTAX</h2>
<code>batch_run(tstop, tstep, "<var>filename</var>")</code><br>
<code>batch_run(tstop, tstep, "<var>filename</var>", "comment")</code><br>
<h2>DESCRIPTION</h2>
This command replaces the set of commands:
<blockquote><pre>
while (t &lt; tstop) {
        for i=0, tstep/dt {
                fadvance()
        }
        // print results to filename
}
</pre></blockquote>
and produces the most efficient run on any given neuron model.  This
command was created specifically for Cray computers in order eliminate
the interpreter overhead as the rate limiting simulation step.
<p>
This command will save selected variables, as they are changed in the run, 
into a file whose name is given as the third argument.
The 4th comment argument is placed at the beginning of the file.
The <a href="nrnoc.html#batch_save">batch_save</a> command specifies which variable are to be saved.
<p>
<p>
	
<p><hr><p>
<h1><a name="batch_save">batch_save</a></h1>
<pre>
<a href="nrnoc.html#functions">functions</a>
</pre>
<h2>SYNTAX</h2>
<code>batch_save()</code><br>
<code>batch_save(&<var>var</var>, &<var>var</var>, ...)</code><br>
<h2>DESCRIPTION</h2>
<dl>
<dt> <code>batch_save()</code>
<dd> starts a new list of variables to save in a <a href="nrnoc.html#batch_run">batch_run</a> .
<dt> <code>batch_save(&<var>var</var>, &<var>var</var>, ...)</code>
<dd> adds pointers to the list of variables to be saved in a <code>batch_run</code>.
	A pointer to a range variable, eg. "v", must have an explicit
	arc length, eg. axon.v(.5).
</dl>
<p>
<h2>EXAMPLES</h2>
<blockquote><pre>
batch_save()	//This clears whatever list existed and starts a new
		//list of variables to be saved.
batch_save(&amp;soma.v(.5), &amp;axon.v(1))
for i=0,2 {
	batch_save(&amp;dend[i].v(.3))
}
</pre></blockquote>
specifies five quantities to be saved from each <code>batch_run</code>.
<p>
<p><hr><p>
<h1><a name="initnrn">initnrn</a></h1>
<pre>
<a href="nrnoc.html#functions">functions</a>
</pre>
<h2>SYNTAX</h2>
<code>initnrn()</code><br>
<h2>DESCRIPTION</h2>
	Initialize <code>t, dt, clamp_resist</code>, and <code>celsius</code> to the values
	they had when the program was first run. 
<p>
	Note that in this
	version <code>Ra</code> is no longer a global variable but a section variable
	like <var>L</var> and <var>rallbranch.</var> Thus <code>Ra</code> can be different for different
	sections.  In order to set <code>Ra</code> to a constant value, use:
<p>
		<code>forall Ra=...</code>
<h2>BUGS</h2>
Not very useful. No way to completely restart neuron exect to <a href="../general/function/ocfunc.html#quit">quit</a> and
re-load.
<p><hr><p>
<h1><a name="fadvance">fadvance</a></h1>
<pre>
<a href="nrnoc.html#functions">functions</a>
</pre>
<h2>SYNTAX</h2>
<code> fadvance()</code><br>
<h2>DESCRIPTION</h2>
Integrate all section equations over the interval <a href="../stdrun/runctrl.html#dt">dt</a> .
The value of <a href="../stdrun/runctrl.html#t">t</a> is incremented by dt.
The default method is first order implicit but may be changed to
Crank-Nicholson by changing <a href="nrnoc.html#secondorder">secondorder</a> = 2.
<p>
fadvance integrates the equation over the dt step by
calling all the BREAKPOINT blocks of models at t+dt/2 twice with
v+.001 and v in order to compute the current and conductance to form
the matrix conductance*voltage = current.
This matrix is then solved for v(t+dt).
(if secondorder == 2 the ionic currents are adjusted to be second order
correct. If secondorder == 1 the ionic currents are not adjusted but
the voltages are second order correct)
Lastly the SOLVE statement within the BREAKPOINT block of models is
executed with t+dt and the new values of v in order to integrate those
states (from new t-.5dt to new t+.5dt).
<p>
<p><hr><p>
<h1><a name="finitialize">finitialize</a></h1>
<pre>
<a href="nrnoc.html#functions">functions</a>
</pre>
<h2>SYNTAX</h2>
<code>finitialize()</code><br>
<code>finitialize(<var>v</var>)</code><br>
<h2>DESCRIPTION</h2>
	Call the INITIAL block for all mechanisms and point processes
	inserted in the sections.
	If the optional argument is present then all voltages of all sections
	are initialized to <var>v.</var>
	<code>t</code> is set to 0.
	
The order of principal actions during an finitialize call is;
<blockquote><pre>
t = 0
Clear the event queue.
Random.play values assigned to variables.
Make sure internal structures needed by integration methods are consistent
  with the current biophysical spec.
Vector.play at t=0 values assigned to variables.
All v = arg if the arg is present.
Type 0 FInitializeHandler statements executed.
All mechanism BEFORE INITIAL blocks are called.
All mechanism INITIAL blocks called.
   Mechanisms that WRITE concentrations are after ion mechanisms and
   before mechanisms that READ concentrations.
LinearMechanism states are initialized
INITIAL blocks inside NETRECEIVE blocks are called.
All mechanism AFTER INITIAL blocks are called.
Type 1 FInitializeHandler statements executed.
The INITIAL block net_send(0, flag) events are delivered.
Effectively a call to CVode.re_init or fcurrent(), whichever appropriate.
Various record functions at t=0. e.g. CVode.record, Vector.record 
Type 2 FInitializeHandler statements executed.

</pre></blockquote>
<h2>SEE ALSO</h2>
<a href="classes/finithnd.html#FInitializeHandler">FInitializeHandler</a> <a href="../stdrun/runctrl.html#Init">Init</a> <a href="classes/cvode.html#re_init">re_init</a> <a href="nrnoc.html#fcurrent">fcurrent</a> <a href="nrnoc.html#frecord_init">frecord_init</a>
<p>
<p><hr><p>
<h1><a name="frecord_init">frecord_init</a></h1>
<pre>
<a href="nrnoc.html#functions">functions</a>
</pre>
<h2>SYNTAX</h2>
<code>frecord_init()</code><br>
<h2>DESCRIPTION</h2>
Initializes the Vectors which are recording variables. i.e. resize to 0 and
append the current values of the variables.  This is done at the end
of an <a href="nrnoc.html#finitialize">finitialize</a> call but needs to be done again to complete initialization
if the user changes states or assigned variables that are being recorded..
<h2>SEE ALSO</h2>
<a href="../general/classes/vector/vect.html#record">record</a> <a href="../stdrun/runctrl.html#Init">Init</a>
<p>
<p><hr><p>
<h1><a name="fstim">fstim</a></h1>
<pre>
<a href="nrnoc.html#functions">functions</a>
</pre>
<h2>SYNTAX</h2>
<code> fstim()</code><br>
<h2>DESCRIPTION</h2> 
Consider this obsolete.  Nevertheless, it does work. See the old NEURON reference
	manual.
<p>
<p><hr><p>
<h1><a name="fstimi">fstimi</a></h1>
<pre>
<a href="nrnoc.html#functions">functions</a>
</pre>
<h2>SYNTAX</h2>
<code> fstimi()</code><br>
<h2>DESCRIPTION</h2> 
Obsolete
<p>
<p><hr><p>
<h1><a name="fit_praxis">fit_praxis</a></h1>
<pre>
<a href="nrnoc.html#functions">functions</a>
</pre>
<h2>SYNTAX</h2>
<code>min = fit_praxis(<var>n</var>, "<var>funname</var>", &<var>x</var>[0])</code><br>
<code>min = fit_praxis(<var>n</var>, "<var>funname</var>", <var>Vector</var>)</code><br>
<code>min = fit_praxis(..., ..., ..., "after quad statement")</code><br>
<code>min = fit_praxis(efun_as_python_callable, hoc_vector)</code><br>
<h2>DESCRIPTION</h2>
	This is the principal axis method for minimizing a function. See praxis.c
	in the scopmath library.
<p>
<dl>
<dt> <code>1 <= n < 20</code>
<dd> is the number of parameters to vary (number
	of arguments to <var>funname</var>). 
<dt> <var>funname</var>
<dd> the name of the function to minimize, eg. least square difference between model and data.
The funname must take two arguments, the first arg, <code>$1</code>,
is the number of elements in second arg vector, <code>$&2</code>. The ith index of the
vector is given by <code>$&2[i]</code>.
<dt> <var>x</var> 
<dd> is a double vector of at least length <var>n.</var> Prior to the call set
	it to a guess of the parameter values. On return it contains the
	values of the args that minimize <code>funname()</code>. 
</dl>
<p>
<var>funname</var> may be either
	an interpreted hoc function or a compiled NMODL function.
<p>
If the variable stoprun is set to 1 during a call to fit_praxis, it will
return immediately (when the current call to  funname returns) with
a return value and varx values set to the best minimum found so far. Use
<a href="nrnoc.html#stop_praxis">stop_praxis</a> to stop after finishing the current principal axis calculation.
<p>
The fourth argument, if present, specifies a statement to be executed at
the end of each principal axis evaluation.
<p>
If the third argument is a Vector, then that style is used to specify
the initial starting point and return the final value. However the
function is still called with second arg as a pointer into a double array.
<p>
The Python callable form uses a Python Callable as the function to
minimize and it must take a single hoc Vector argument specifying the
values of the parameters for use in evaluation the function. On entry to 
fit_praxis the Vector specifies the number of parameters and the
parameter starting values. On return the vector contains the values of
parameters which generated the least minimum found so far.
<p>
Hoc example: minimize (x+y - 5)^2 + 5*((x-y) - 15)^2
<blockquote><pre>
objref vec
vec = new Vector(2) // vec.x[0] is x, vec.x[1] is y
func efun() {local x, y
  x = $&amp;2[0]  y = $&amp;2[1]
  return (x+y - 5)^2 + 5*(x-y - 15)^2
}
attr_praxis(1e-5, .5, 0)
e = fit_praxis(vec.size(), "efun", vec)
printf("e=%g x=%g y=%g\n", e, vec.x[0], vec.x[1])

objref paxis
paxis = new Vector()
for i=0, 1 {
  pval = pval_praxis(i, paxis)
  printf("%d  %10g      %10g %10g\n", i, pval, paxis.x[0], paxis.x[1])
}
</pre></blockquote>
<p>
Python example:
<blockquote><pre>
from neuron import h
v = h.Vector(2)
def efun(v):
  return (v.x[0]+v.x[1] - 5)**2 + 5*(v.x[0]-v.x[1] - 15)**2
h.attr_praxis(1e-5, .5, 0)
e = h.fit_praxis(efun, v)
print "e=%g x=%g y=%g\n"%(e, v.x[0], v.x[1])
</pre></blockquote>
<h2>BUGS</h2>
Up to version 4.0.1, the arguments to <var>funname</var> were an explicit
list of <var>n</var> arguments. ie <code>numarg()==n</code>.
<h2>SEE ALSO</h2>
<a href="nrnoc.html#attr_praxis">attr_praxis</a> , <a href="nrnoc.html#stop_praxis">stop_praxis</a> , <a href="nrnoc.html#pval_praxis">pval_praxis</a>
<p>
<p><hr><p>
<h1><a name="attr_praxis">attr_praxis</a></h1>
<pre>
<a href="nrnoc.html#functions">functions</a>
</pre>
<h2>SYNTAX</h2>
<code> attr_praxis(<var>tolerance</var>, <var>maxstepsize</var>, <var>printmode</var>)</code><br>
<code>previous_index = attr_praxis(mcell_ran4_index)</code><br>
<h2>DESCRIPTION</h2>
	Set the attributes of the praxis method. This must be called before
the first call to <a href="nrnoc.html#fit_praxis">fit_praxis</a> .
<dl>
<dt> tolerance
<dd> praxis attempt to return f(x) such that if x0 is the true
		local minimum then <code>norm(<var>x</var>-<var>x0</var>) < tolerance</code>
<dt> maxstepsize
<dd> should be set to about the maximum distance from
		initial guess to the minimum.
<dt> printmode=0	
<dd>		no printing
<dt> printmode=1,2,3
<dd>	more and more verbose
</dl>
The single argument form causes praxis to pick its random numbers from
the the mcellran4 generator beginning at the specified index. This
allows reproducible fitting. The return value is the previously picked
index. (see <a href="../general/function/mcran4.html#mcell_ran4">mcell_ran4</a> )
<p>
<p><hr><p>
<h1><a name="pval_praxis">pval_praxis</a></h1>
<pre>
<a href="nrnoc.html#functions">functions</a>
</pre>
<h2>SYNTAX</h2>
<code>pval = pval_praxis(<var>i</var>)</code><br>
<code>pval = pval_praxis(<var>i</var>, &<var>paxis</var>[0])</code><br>
<code>pval = pval_praxis(<var>i</var>, <var>Vector</var>)</code><br>
<h2>DESCRIPTION</h2>
	Return the ith principal value. If the second argument is present, <code>pval_praxis</code> also fills
	the vector with the ith principal axis.
<p>
<p><hr><p>
<h1><a name="stop_praxis">stop_praxis</a></h1>
<pre>
<a href="nrnoc.html#functions">functions</a>
</pre>
<h2>SYNTAX</h2>
<code>stop_praxis()</code><br>
<code>stop_praxis(i)</code><br>
<h2>DESCRIPTION</h2>
Set a flag in the praxis function that will cause it to stop after
        it finishes the current (or ith subsequent)
	 principal axis calculation. If this function  
        is called before <code>fit_praxis</code>, then praxis will do a single 
	(or i) principal axis calculation and then exit. 
<p>
<p><hr><p>
<h1><a name="fclamp">fclamp</a></h1>
<pre>
<a href="nrnoc.html#functions">functions</a>
</pre>
<h2>SYNTAX</h2>
<code> fclamp()</code><br>
<h2>DESCRIPTION</h2>
obsolete. Use the <a href="../stdrun/electrod.html#VClamp">VClamp</a> or <a href="mech.html#SEClamp">SEClamp</a> point process.
<p>
<p><hr><p>
<h1><a name="fclampi">fclampi</a></h1>
<pre>
<a href="nrnoc.html#functions">functions</a>
</pre>
<h2>SYNTAX</h2>
<code> fclampi()</code><br>
<h2>DESCRIPTION</h2>
obsolete. Use the <a href="../stdrun/electrod.html#VClamp">VClamp</a> or <a href="mech.html#SEClamp">SEClamp</a> point process.
<p>
<p><hr><p>
<h1><a name="fclampv">fclampv</a></h1>
<pre>
<a href="nrnoc.html#functions">functions</a>
</pre>
<h2>SYNTAX</h2>
<code>fclampv()</code><br>
<h2>DESCRIPTION</h2>
obsolete. Use the <a href="../stdrun/electrod.html#VClamp">VClamp</a> or <a href="mech.html#SEClamp">SEClamp</a> point process.
<p>
<p><hr><p>
<h1><a name="prstim">prstim</a></h1>
<pre>
<a href="nrnoc.html#functions">functions</a>
</pre>
<h2>SYNTAX</h2>
<code> prstim()</code><br>
<h2>DESCRIPTION</h2>
 obsolete. Print the info about <code>fstim</code>, <code>fclamp</code>, and <code>fsyn</code>
<p>
<p><hr><p>
<h1><a name="fcurrent">fcurrent</a></h1>
<pre>
<a href="nrnoc.html#functions">functions</a>
</pre>
<h2>SYNTAX</h2>
<code> fcurrent()</code><br>
<h2>DESCRIPTION</h2>
	Make all assigned variables (currents, conductances, etc)
	consistent with the values of the states. Useful in combination
with <a href="nrnoc.html#finitialize">finitialize</a> .
<h2>EXAMPLES</h2>
<a href="fcurrent.hoc">execute following example</a>
<blockquote><pre>
create soma
access soma
insert hh
print "default el_hh = ", el_hh
// set el_hh so that the steady state is exactly -70 mV
finitialize(-70) // sets v to -70 and m,h,n to corresponding steady state values

fcurrent()	// set all assigned variables consistent with states

// use current balance: 0 = ina + ik + gl_hh*(v - el_hh)		
el_hh = (ina + ik + gl_hh*v)/gl_hh

print "-70 mV steady state el_hh = ", el_hh
fcurrent()	// recalculate currents (il_hh)
</pre></blockquote>
<p>
<p><hr><p>
<h1><a name="fmatrix">fmatrix</a></h1>
<pre>
<a href="nrnoc.html#functions">functions</a>
</pre>
<h2>SYNTAX</h2>
<code> fmatrix()</code><br>
<h2>DESCRIPTION</h2>
	Print the jacobian matrix for the tree structure in a particularly
	confusing way. for debugging only.
<p>
<p><hr><p>
<h1><a name="issection">issection</a></h1>
<pre>
<a href="nrnoc.html#functions">functions</a>
</pre>
<h2>SYNTAX</h2>
<code> issection("<var>regular</var> <var>expression</var>")</code><br>
<h2>DESCRIPTION</h2>
	Return 1 if the currently accessed section matches the regular expression.  
	Return 0 if otherwise.
<p>
	Regular expressions are like those of grep except {} are used
	in place of [] to avoid conflict with indexed sections. Thus
	a[{8-15}] matches sections a[8] through a[15].
	A match always begins from the beginning of a section name. If you
	don't want to require a match at the beginning use the dot. 
<p>
	(Note,
	that <code>.</code> matches any character and <code>*</code> matches 0 or more occurrences
	of the previous character). The interpreter always closes each string with
	an implicit <code>$</code> to require a match at the end of the string. If you
	don't require a match at the end use "<code>.*</code>".
<h2>EXAMPLES</h2>
<blockquote><pre>
create soma, axon, dendrite[3]
forall if (issection("s.*")) {
	print secname()
}
</pre></blockquote>
will print <code>soma</code>
<blockquote><pre>
forall if (issection("d.*2]")) {
	print secname()
}
</pre></blockquote>
will print <code>dendrite[2]</code>
<blockquote><pre>
forall if (issection(".*a.*")) {
	print secname()
}
</pre></blockquote>
will print all names which contain the letter "a"
<blockquote><pre>
soma
axon
</pre></blockquote>
<h2>SEE ALSO</h2>
<a href="secspec.html#ifsec">ifsec</a> <a href="secspec.html#forsec">forsec</a>
<p>
<p><hr><p>
<h1><a name="ismembrane">ismembrane</a></h1>
<pre>
<a href="nrnoc.html#functions">functions</a>
</pre>
<h2>SYNTAX</h2>
<code> ismembrane("<var>mechanism</var>")</code><br>
<h2>DESCRIPTION</h2>
	This function returns a 1 if the current membrane contains this
	(density) mechanism.  This is not for point
	processes. 
<p>
<h2>EXAMPLES</h2>
<blockquote><pre>
forall if (ismembrane("hh") &amp;&amp; ismembrane("ca_ion")) {
	print secname()
}
</pre></blockquote>
will print the names of all the sections which contain both Hodgkin-Huxley and Calcium ions.
<p>
<p><hr><p>
<h1><a name="sectionname">sectionname</a></h1>
<pre>
<a href="nrnoc.html#functions">functions</a>
</pre>
<h2>SYNTAX</h2>
<code> sectionname(<var>strvar</var>)</code><br>
<h2>DESCRIPTION</h2>
	The name of the currently accessed section is placed in <var>strvar.</var>
<p>
This function is superseded by the easier to use, <a href="nrnoc.html#secname">secname</a> .
<p>
<p><hr><p>
<h1><a name="secname">secname</a></h1>
<pre>
<a href="nrnoc.html#functions">functions</a>
</pre>
<h2>SYNTAX</h2>
<code> secname()</code><br>
<h2>DESCRIPTION</h2>
	Returns the currently accessed section name. Usage is
<blockquote><pre>
		strdef s
		s = secname()
</pre></blockquote>
	or
<blockquote><pre>
		print secname()
</pre></blockquote>
	or
<blockquote><pre>
		forall for(x) printf("%s(%g)\n", secname(), x)
</pre></blockquote>
<p>
<p><hr><p>
<h1><a name="psection">psection</a></h1>
<pre>
<a href="nrnoc.html#functions">functions</a>
</pre>
<h2>SYNTAX</h2>
<code> psection()</code><br>
<h2>DESCRIPTION</h2>
	Print info about currently accessed section in a format which is executable.
 (length, parent, diameter, membrane information)
<p>
<p>
<p>
<p><hr><p>
<h1><a name="secondorder">secondorder</a></h1>
<pre>
<a href="../1nrn.html#globals">globals</a>
</pre>
<h2>SYNTAX</h2>
<code>secondorder</code><br>
<h2>DESCRIPTION</h2>
	This is a global variable which specifies the time integration method.
<dl>
<dt> =0 
<dd> default fully implicit backward euler. Very numerically stable.
	gives steady state in one step when <code><var>dt</var>=1e10</code>. Numerical errors
	are proportional to <var>dt.</var>
<dt> =1 
<dd> crank-nicholson Can give large (but damped) numerical error
	oscillations. For small <code>dt</code> the numerical errors are proportional
	to <code>dt^2</code>. Cannot be used with voltage clamps. Ionic currents
	are first order correct. Channel conductances are second order
	correct when plotted at <code>t+dt/2</code>
<dt> =2 
<dd> crank-nicholson like 1 but in addition Ion currents (<var>ina</var>, <var>ik</var>,
	etc) are fixed up so that they are second order correct when
	plotted at <code>t-dt/2</code>
</dl>
<p>
<p><hr><p>
<h1><a name="t">t</a></h1>
<pre>
<a href="../1nrn.html#globals">globals</a>
</pre>
<h2>SYNTAX</h2>
<code>t</code><br>
<h2>DESCRIPTION</h2>
	The global time variable.
<p>
<p><hr><p>
<h1><a name="dt">dt</a></h1>
<pre>
<a href="../1nrn.html#globals">globals</a>
</pre>
<h2>SYNTAX</h2>
<code>dt</code><br>
<h2>DESCRIPTION</h2>
The integration interval for <a href="nrnoc.html#fadvance">fadvance</a> ().
<p>
When using the default implicit integration method ( <a href="nrnoc.html#secondorder">secondorder</a> = 0)
there is no upper limit on dt for numerical stability and in fact for
passive models it is often convenient to use dt=1.9 to obtain the
steady state in a single time step.
<p>
dt can be changed by the user at any time during a simulation. However,
some inserted mechanisms may use tables which depend on the value of dt
which will be automatically recomputed. In this situation, the tables
are not useful and should be bypassed by setting the appropriate
usetable_suffix global variables to 0.
<p>
<p><hr><p>
<h1><a name="clamp_resist">clamp_resist</a></h1>
<pre>
<a href="../1nrn.html#globals">globals</a>
</pre>
<h2>SYNTAX</h2>
<code>clamp_resist</code><br>
<h2>DESCRIPTION</h2>
	Obsolete, used by fclamp.
<p>
<p><hr><p>
<h1><a name="celsius">celsius</a></h1>
<pre>
<a href="../1nrn.html#globals">globals</a>
</pre>
<h2>SYNTAX</h2>
<code>celsius = 6.3</code><br>
<h2>DESCRIPTION</h2>
Temperature in degrees centigrade.
<p>
Generally, rate function tables ( eg. used by the hh mechanism)
depend on temperature and will automatically be re-computed
whenever celsius changes.
<p>
<p><hr><p>
<h1><a name="stoprun">stoprun</a></h1>
<pre>
<a href="../1nrn.html#globals">globals</a>
</pre>
<h2>SYNTAX</h2>
<code>stoprun</code><br>
<h2>DESCRIPTION</h2>
A flag which is watched by <a href="nrnoc.html#fit_praxis">fit_praxis</a> , <a href="classes/cvode.html#CVode">CVode</a> , and other procedures
during a run or family of runs.
When stoprun==1 they will immediately return without completing
normally. This allows safe stopping in the middle of a long run. Procedures
that do multiple runs should check stoprun after each run and exit
gracefully. The <a href="../stdrun/runctrl.html#Stop">Stop</a> of the RunControl GUI sets this variable.
It is cleared at the beginning of a run or when continuing a run.
<p>
<p>
<p><hr><p>
<h1><a name="this_section">this_section</a></h1>
<pre>
<a href="nrnoc.html#functions">functions</a>
</pre>
<h2>SYNTAX</h2>
<code>this_section(<var>x</var>)</code><br>
<h2>DESCRIPTION</h2>
	Return a pointer (coded as a double) to the section which contains location 0 of the
	currently accessed section. This pointer can be used as the argument
to <a href="secspec.html#push_section">push_section</a> . Functions that return pointers coded as doubles
are unsafe with 64 bit pointers. This function has been superseded by
<a href="classes/secref.html#SectionRef">SectionRef</a> . See <a href="classes/secref.html#sec">sec</a> .
<p>
<p><hr><p>
<h1><a name="this_node">this_node</a></h1>
<pre>
<a href="nrnoc.html#functions">functions</a>
</pre>
<h2>SYNTAX</h2>
<code>this_node(<var>x</var>)</code><br>
<h2>DESCRIPTION</h2>
Return a pointer (coded as a double) to the segment
of the currently accessed section that
contains location <var>x.</var> If you wish to compute a segment number
index where 1 is the first nonzero area segment and nseg is the last
nonzero area segment
of the currently accessed section corresponding to position x use the
hoc function
<blockquote><pre>
func segnum() {
        if ($1 &lt;= 0) {
                return 0
        }else if ($1 &gt;= 1) {
                return nseg+1
        }else {
                return int($1*nseg + .5)
        }
}
</pre></blockquote>
<h2>BUGS</h2>
This function is useless and should be removed.
<p>
<p><hr><p>
<h1><a name="parent_section">parent_section</a></h1>
<pre>
<a href="nrnoc.html#functions">functions</a>
</pre>
<h2>SYNTAX</h2>
<code>parent_section(<var>x</var>)</code><br>
<h2>DESCRIPTION</h2>
	Return the pointer to the section parent of the segment containing <var>x.</var>
	Because a 64 bit pointer cannot safely be represented as a
double this function is deprecated in favor of <a href="classes/secref.html#parent">parent</a> .
<p>
<p><hr><p>
<h1><a name="parent_node">parent_node</a></h1>
<pre>
<a href="nrnoc.html#functions">functions</a>
</pre>
<h2>SYNTAX</h2>
<code>parent_node(<var>x</var>)</code><br>
<h2>DESCRIPTION</h2>
	Return the pointer of the parent of the segment containing <var>x.</var>
<h2>BUGS</h2>
This function is useless and currently returns an error.
<p>
<p><hr><p>
<h1><a name="parent_connection">parent_connection</a></h1>
<pre>
<a href="nrnoc.html#functions">functions</a>
</pre>
<h2>SYNTAX</h2>
<code><var>y</var> = parent_connection()</code><br>
<h2>DESCRIPTION</h2>
        Return location on parent that currently accessed section is
        connected to. (0 <= x <= 1). This is the value, y, used in
<blockquote><pre>
        connect child(x), parent(y)
</pre></blockquote>
<p>
<p><hr><p>
<h1><a name="section_orientation">section_orientation</a></h1>
<pre>
<a href="nrnoc.html#functions">functions</a>
</pre>
<h2>SYNTAX</h2>
<code><var>y</var> = section_orientation()</code><br>
<h2>DESCRIPTION</h2>
        Return the end (0 or 1) which connects to the parent. This is the
value, x, used in
<p>
<blockquote><pre>
        connect child(x), parent(y)
</pre></blockquote>
<p>
<p>
<p><hr><p>
<h1><a name="CompileTimeOptions">CompileTimeOptions</a></h1>
<pre>
<a href="../1nrn.html#neuron">neuron</a>
</pre>
The following definitions are found in nrnoc/SRC/options.h and add extra
functionality which not everyone may need. The extras come at the cost
of larger memory requirements for node and section structures. METHOD3 is too large
and obscure to benefit most users.
<blockquote><pre>
#define VECTORIZE	1	/* hope this speeds up simulations on a Cray */
				/* this is no longer optional */

#define EXTRACELLULAR	1	/* extracellular membrane mechanism */

#define DIAMLIST	1	/* section contains diameter info */
				/* shape plots make use of this */

#define EXTRAEQN	0	/* ionic concentrations calculated via
				 * jacobian along with v (not implemented) */
#if DIAMLIST
#define NTS_SPINE	1	/* A negative diameter in pt3dadd() tags that
				 * diamlist location as having a spine.
				 * diam3d() still returns the positive diameter
				 * spined3d() returns 1 or 0 signifying presence
				 * of spine. setSpineArea() tells how much
				 * area/spine to add to the segment. */
#endif

#define METHOD3		1	/* third order spatially correct method */
				/* testing only, not completely implemented */
				/* not working at this time */

#if METHOD3
 spatial_method(i)
	no arg, returns current method
	i=0 The standard NEURON method with zero area nodes at the ends
		of sections.
	i=1 conventional method with 1/2 area end nodes
	i=2 modified second order method
	i=3 third order correct spatial method
	Note: i=1-3 don't work under all circumstances. They have been
	insufficiently tested and the correctness must be established for
	each simulation.
#endif

#if NEMO
neuron2nemo("filename") Beginning of translator between John Millers
		nemosys program	and NEURON. Probably out of date.
nemo2neuron("filename")
#endif
</pre></blockquote>
<p>
<p>
<p><hr><p>
<h1><a name="ion">ion</a></h1>
<pre>
<a href="../1nrn.html#neuron">neuron</a>
   <a href="nrnoc.html#ghk">ghk</a>            <a href="nrnoc.html#ion_register">ion_register</a>   <a href="nrnoc.html#nernst">nernst</a>         
   <a href="nrnoc.html#ion_charge">ion_charge</a>     <a href="nrnoc.html#ion_style">ion_style</a>      
</pre>
<p><hr><p>
<h1><a name="ion_style">ion_style</a></h1>
<pre>
<a href="nrnoc.html#ion">ion</a>
</pre>
<h2>SYNTAX</h2>
<code>oldstyle = ion_style("<var>name_ion</var>", <var>c_style</var>, <var>e_style</var>, <var>einit</var>, <var>eadvance</var>, <var>cinit</var>)</code><br>
<code>oldstyle = ion_style("<var>name_ion</var>")</code><br>
<h2>DESCRIPTION</h2>	
In the currently accessed section,
	force the named ion (eg. na_ion, k_ion, ca_ion, etc) to handle
	reversal potential and concentrations according to the indicated
	styles.
	You will not often need this function since the
	style chosen automatically on a per section basis should be
	appropriate to the set of mechanisms inserted in each section.
	
Warning: if other mechanisms are inserted subsequent to a call
	of this function, the style will be "promoted" according to
	the rules associated with adding the used ions to the style
	previously in effect.
<p>
The oldstyle value is previous internal setting of
c_style + 4*cinit +  8*e_style + 32*einit + 64*eadvance.
<p>
<dl>
<dt> c_style: 0, 1, 2, 3.
<dd> Concentrations respectively treated as UNUSED,
PARAMETER, ASSIGNED, or STATE variables.  Determines which panel (if
any) will show the concentrations. 
<dt> e_style: 0, 1, 2, 3.
<dd> Reversal potential respectively treated as
UNUSED, PARAMETER, ASSIGNED, or STATE variable.
<dt> einit: 0 or 1.
<dd> If 1 then reversal potential computed by Nernst equation
on call to <code>finitialize()</code> using values of concentrations.
<dt> eadvance: 0 or 1.
<dd> If 1 then reversal potential computed every call to
<code>fadvance()</code> using the values of the concentrations.
<dt> cinit: 0 or 1.
<dd> If 1 then a call to finitialize() sets the concentrations
to the values of the global initial concentrations. eg. <code>nai</code> set to
<code>nai0_na_ion</code> and <code>nao</code> set to <code>nao0_na_ion</code>.
</dl>
<p>
The automatic style is chosen based on how the set of mechanisms that
have been inserted in a section use the ion. Note that the precedence is
WRITE > READ > unused in the USEION statement; so if one mechanism
READ's  cai/cao and another mechanism WRITE's them then WRITE takes precedence
in the following table. For compactness, the table assumes the ca ion.
Each table entry identifies the equivalent parameters to the ion_style
function.
<pre>
cai/cao	->	unused		read		write
<p>
eca unused	0,0,0,0,0	1,0,0,0,0	3,0,0,0,1
<p>
eca read	0,1,0,0,0	1,2,1,0,0	3,2,1,1,1
<p>
eca write	0,2,0,0,0	1,2,0,0,0	3,2,0,0,1
</pre>
For example suppose one has inserted a mechanism that READ's eca,
a mechanism that READ's cai, cao and a mechanism that WRITE's cai, cao
Then, since WRITE takes precedence over READ in the above table,
<code>cai/cao</code> would appear in the STATE variable panel (first arg is 3),
<code>eca</code> would appear in the ASSIGNED variable panel (second arg is 2),
<code>eca</code> would be calculated on a call to finitialize (third arg is 1),
<code>eca</code> would be calculated on every call to fadvance (fourth arg is 1),
<code>cai/cao</code> would be initialized (on finitialize) to the global variables
<code>cai0_ca_ion</code> and <code>cao0_ca_ion</code> respectively. (note that this takes place just
before the calculation of <code>eca</code>).
<p>
<p><hr><p>
<h1><a name="ghk">ghk</a></h1>
<pre>
<a href="nrnoc.html#ion">ion</a>
</pre>
<h2>SYNTAX</h2>
<code> ghk(<var>v</var>, <var>ci</var>, <var>co</var>, <var>charge</var>)</code><br>
<h2>DESCRIPTION</h2>
Return the Goldman-Hodgkin-Katz current (normalized to unit permeability).
Use the present value of celsius.
<blockquote><pre>
mA/cm2 = (permeability in cm/s)*ghk(mV, mM, mM, valence)
</pre></blockquote>
<p>
<p><hr><p>
<h1><a name="nernst">nernst</a></h1>
<pre>
<a href="nrnoc.html#ion">ion</a>
</pre>
<h2>SYNTAX</h2>
<code>nernst(<var>ci</var>, <var>co</var>, <var>charge</var>)</code><br>
<code>nernst("<var>ena</var>" or "<var>nai</var>" or "<var>nao</var>", [<var>x</var>])</code><br>
<h2>DESCRIPTION</h2>
<dl>
<dt> <code>nernst(<var>ci</var>, <var>co</var>, <var>charge</var>)</code>
<dd> returns nernst potential. Utilizes the present value of celsius.
<dt> <code>nernst("<var>ena</var>" or "<var>nai</var>" or "<var>nao</var>", [<var>x</var>])</code>
<dd> calculates <code><var>nao</var>/<var>nai</var> = exp(z*<var>ena</var>/RTF)</code> for the ionic variable 
named in the string.
</dl>
Celsius, valence, and the other two ionic variables are taken from their
values at the currently accessed section at position x (.5 default).
A hoc error is printed if the ionic species does not exist at this location.
<p>
<p><hr><p>
<h1><a name="ion_register">ion_register</a></h1>
<pre>
<a href="nrnoc.html#ion">ion</a>
</pre>
<h2>SYNTAX</h2>
<code>type = ion_register("name", charge)</code><br>
<h2>DESCRIPTION</h2>
Create a new ion type with mechanism name, "name_ion", and associated
variables: iname, nameo, namei, ename.
If any of these names already
exists and name_ion is not already an ion, the function returns -1,
otherwise it returns the mechanism type index. If name_ion is already
an ion the charge is ignored but the type index is returned.
<p>
<p><hr><p>
<h1><a name="ion_charge">ion_charge</a></h1>
<pre>
<a href="nrnoc.html#ion">ion</a>
</pre>
<h2>SYNTAX</h2>
<code>charge = ion_charge("name_ion")</code><br>
<h2>DESCRIPTION</h2>
Return the charge for the indicated ion mechanism. An error message is
printed if name_ion is not an ion mechanism.
<p><hr><p>
<date>
neuron/neuron/nrnoc.hel : Sep 21 09:30
