<h1><a name="Random">Random</a></h1>
<pre>
<a href="../../0nrn.html#classes">classes</a>
   <a href="random.html#ACG">ACG</a>            <a href="random.html#binomial">binomial</a>       <a href="random.html#lognormal">lognormal</a>      <a href="random.html#repick">repick</a>         
   <a href="random.html#MCellRan4">MCellRan4</a>      <a href="random.html#discunif">discunif</a>       <a href="random.html#negexp">negexp</a>         <a href="random.html#seq">seq</a>            
   <a href="random.html#MLCG">MLCG</a>           <a href="random.html#erlang">erlang</a>         <a href="random.html#normal">normal</a>         <a href="random.html#uniform">uniform</a>        
   <a href="random.html#Random123">Random123</a>      <a href="random.html#geometric">geometric</a>      <a href="random.html#play">play</a>           <a href="random.html#weibull">weibull</a>        
   <a href="random.html#Random123_globalindex">Random123_globalindex</a>  <a href="random.html#hypergeo">hypergeo</a>  <a href="random.html#poisson">poisson</a>     
</pre>
Random 
<h2>SYNTAX</h2>
<code>Random()</code><br>
<code>Random(<var>seed</var>)</code><br>
<code>Random(<var>seed</var>, <var>size</var>)</code><br>
<h2>DESCRIPTION</h2>
The Random class provides commonly used random distributions which are
useful for stochastic 
simulations. The default distribution is normal with mean = 0 and standard
deviation = 1.
<p>
This class is an interface to the RNG class
from the gnu c++ class library. As of version 5.2, a cryptographic quality
RNG class wrapper for <a href="../function/mcran4.html#mcell_ran4">mcell_ran4</a> was added and is available
with the <a href="random.html#MCellRan4">MCellRan4</a> method. The current default random generator
is <a href="random.html#ACG">ACG</a> .
<p>
As of version 7.3, a more versatile cryptographic quality generator,
Random123, is available with the <a href="random.html#Random123">Random123</a> method. This generator
uses a 34bit counter, 2 32 bit identifiers, and a 32 bit global index and
is most suitable for managing separate independent, reproducible, restartable
streams that are unique to individual cell and synapses in large parallel
network models.
See: http://www.thesalmons.org/john/random123/papers/random123sc11.pdf
<p>
Note that multiple instances of the Random class will produce different
streams of random numbers only if their seeds are different.
<p>
One can switch distributions at any time but if the distribution is
stationary then it is more efficient to use r.repick() to avoid
constructor/destructor overhead.
<p>
<h2>EXAMPLES</h2>
<blockquote><pre>
objref r
r = new Random()
for i=1,10 print r.uniform(30, 50) // not as efficient as
for i=1,10 print r.repick()	   // this
</pre></blockquote>
prints 20 random numbers ranging in value between 30 and 50.
<p>
<p>
<p><hr><p>
<h1><a name="ACG">ACG</a></h1>
<pre>
<a href="random.html#Random">Random</a>
</pre>
<h2>SYNTAX</h2>
<code>r.ACG()</code><br>
<code>r.ACG(<var>seed</var>)</code><br>
<code>r.ACG(<var>seed</var>, <var>size</var>)</code><br>
<h2>DESCRIPTION</h2>
Use a variant of the Linear Congruential Generator (algorithm M)
described in Knuth, Art of Computer Programming, Vol. III in
combination with a Fibonacci Additive Congruential Generator.  This is
a "very high quality" random number generator, Default size is 55,
giving a size of 1244 bytes to the structure. Minimum size is 7 (total
100 bytes), maximum size is 98 (total 2440 bytes).
  
<p><hr><p>
<h1><a name="MLCG">MLCG</a></h1>
<pre>
<a href="random.html#Random">Random</a>
</pre>
<h2>SYNTAX</h2>
<code>r.MLCG()</code><br>
<code>r.MLCG(<var>seed1</var>)</code><br>
<code>r.MLCG(<var>seed1</var>, <var>seed2</var>)</code><br>
<h2>DESCRIPTION</h2>
Use a Multiplicative Linear Congruential Generator.  Not as high
quality as the ACG.  It uses only 8 bytes.
<p>
<p><hr><p>
<h1><a name="MCellRan4">MCellRan4</a></h1>
<pre>
<a href="random.html#Random">Random</a>
</pre>
<h2>SYNTAX</h2>
<code>highindex = r.MCellRan4()</code><br>
<code>highindex = r.MCellRan4(highindex)</code><br>
<code>highindex = r.MCellRan4(highindex, lowindex)</code><br>
<h2>DESCRIPTION</h2>
Use the MCell variant of the Ran4 generator. See <a href="../function/mcran4.html#mcell_ran4">mcell_ran4</a> .
In the no argument case or if the highindex is 0, then the system selects
an index which is the random 32 bit integer resulting from
an mcell_ran4 call with an index equal to the
the number of instances of the Random generator that had been created.
Thus, each stream should be statistically independent as long as the
highindex values differ by more than the eventual length of the stream.
In any case, the
initial highindex is returned and can be used to restart an instance
of the generator. Use <a href="../function/mcran4.html#mcell_ran4_init">mcell_ran4_init</a> to set the (global)
low 32 bit index of the generator. The <a href="random.html#seq">seq</a> method is useful
for getting the current sequence number and restarting at that sequence
number (highindex).
If the lowindex arg is present and nonzero, then that lowindex is used
instead of the global one specified by <a href="../function/mcran4.html#mcell_ran4_init">mcell_ran4_init</a> .
This allows 2^32-1 independent streams that do not overlap.
<p>
Note that for reproducibility,
the distribution should be defined AFTER setting the seed since some
distributions, such as <a href="random.html#normal">normal</a> , hold state information from
a previous pick from the uniform distribution.
<h2>SEE ALSO</h2>
<a href="random.html#Random123">Random123</a>
<h2>EXAMPLES</h2>
<a href="mcunif.hoc">execute following example</a>
<blockquote><pre>
objref r, vec, g1, g2, hist
r = new Random()
index = r.MCellRan4()
r.uniform(0, 2)
vec = new Vector(1000)
g1 = new Graph()
g2 = new Graph()
g1.size(0, 1000, 0, 2)
g2.size(0, 2, 0, 150)

proc doit() {
	g1.erase() g2.erase()
	vec.setrand(r)
	hist = vec.histogram(0, 2, 0.2)
	vec.line(g1)
	hist.line(g2, .2)
	g1.flush g2.flush
}
doit()

variable_domain(&amp;index, 0, 2^32-1)
xpanel("MCellRan4 test")
xbutton("Sample", "doit()")
xpvalue("Original index", &amp;index, 1, "r.MCellRan4(index) doit()")
xpanel()
</pre></blockquote>
<p>
<p><hr><p>
<h1><a name="Random123">Random123</a></h1>
<pre>
<a href="random.html#Random">Random</a>
</pre>
0 = r.Random123(id1, id2)
<h2>DESCRIPTION</h2>
Use the Random123 generator (currently philox4x32 is the crypotgraphic hash
used) with the stream identified by the identifiers 0 <= id1 and id1 < 2^32
and the global index (see <a href="random.html#Random123_globalindex">Random123_globalindex</a> ). The counter,
which increments from 0 to 2^34-1, is initialized to 0 (see <a href="random.html#seq">seq</a> ).
<p>
The generators should be usable in the context of threads as long as
no instance is used in more than one thread.
<p>
This generator
uses a 34bit counter, 2 32 bit identifiers, and a 32 bit global index and
is most suitable for managing separate independent, reproducible, restartable
streams that are unique to individual cell and synapses in large parallel
network models.
See: http://www.thesalmons.org/john/random123/papers/random123sc11.pdf 
<p>
<p><hr><p>
<h1><a name="Random123_globalindex">Random123_globalindex</a></h1>
<pre>
<a href="random.html#Random">Random</a>
</pre>
uint32 = r.Random123_globalindex([uint32])
<h2>DESCRIPTION</h2>
Gets and sets the global index used by all instances of the Random123
instances of Random.
<p>
<p><hr><p>
<h1><a name="seq">seq</a></h1>
<pre>
<a href="random.html#Random">Random</a>
</pre>
currenthighindex = r.seq()
r.seq(sethighindex)
<h2>DESCRIPTION</h2>
For MCellRan4,
Gets and sets the current highindex value when the <a href="random.html#MCellRan4">MCellRan4</a> is
in use. This allows restarting the generator at any specified point.
Note that the currenthighindex value is incremented every <a href="random.html#repick">repick</a> .
Usually the increment is 1 but some distributions, e.g. <a href="random.html#poisson">poisson</a>
can increment by more. Also, some distributions, e.g. <a href="random.html#normal">normal</a> ,
pick twice on the first repick but once thereafter.
<p>
For Random123,
Gets and sets the counter value which ranges from 0 to 2^34-1.
The reason the the greater range is that the internal Random123 generators
return 4 uint32 values on each call. So that is done only every 4 picks from
the generator.
<p>
<h2>EXAMPLES</h2>
<a href="seq.hoc">execute following example</a>
<blockquote><pre>
objref r
r = new Random()
//r.uniform(0,1)
r.negexp(1)
//r.normal(0,1)
mcell_ran4_init(1)
r.MCellRan4(1)

for i=0, 10 print i, r.repick

r.MCellRan4(1)
for i=0, 5 print i, r.repick
idum = r.seq
print "idum = ", idum
for i=6, 10 print i, r.repick

print "restarting"
r.seq(idum)
for i=6, 10 print i, r.repick

print "restarting"
r.seq(idum)
for i=6, 10 print i, r.repick
</pre></blockquote>
<p>
<p><hr><p>
<h1><a name="repick">repick</a></h1>
<pre>
<a href="random.html#Random">Random</a>
</pre>
<h2>SYNTAX</h2>
<code>r.repick()</code><br>
<h2>DESCRIPTION</h2>
Pick again from the distribution last used.
<p>
<p><hr><p>
<h1><a name="play">play</a></h1>
<pre>
<a href="random.html#Random">Random</a>
</pre>
<h2>SYNTAX</h2>
<code>r.play(&var)</code><br>
<h2>DESCRIPTION</h2>
At the beginning of every call to <a href="../../neuron/nrnoc.html#fadvance">fadvance</a> and <a href="../../neuron/nrnoc.html#finitialize">finitialize</a> var is set
to a new value equivalent to
<blockquote><pre>
var = r.repick()
</pre></blockquote>
(but with no interpreter overhead). This is similar in concept to <a href="vector/vect.html#play">play</a> .
Play may be called several times for different variables and each variable
will get an independent random value but with the same distribution.
To disconnect the Random object from its list of variables, either the variables
or the Random object must be destroyed.
<h2>EXAMPLES</h2>
<blockquote><pre>
// run the single script
// use the PointProcessManager to select IClamp
// set dur of IClamp[0] to 100
// open a new Voltage Graph
objref r
r = new Random()
r.poisson(.01)
r.play(&amp;IClamp[0].amp)
//open a RunControl
// press Init&amp;Run several times
</pre></blockquote>
<p><hr><p>
<h1><a name="uniform">uniform</a></h1>
<pre>
<a href="random.html#Random">Random</a>
</pre>
<h2>SYNTAX</h2>
<code>r.uniform(<var>low</var>, <var>high</var>)</code><br>
<h2>DESCRIPTION</h2>
Create a uniform random variable over the open interval <var>low...</var><var>high</var>].
<h2>EXAMPLES</h2>
<a href="uniform.hoc">execute following example</a>
<blockquote><pre>
objref r, vec, g1, g2, hist
r = new Random()
r.uniform(0, 2)
vec = new Vector(1000)
vec.setrand(r)
hist = vec.histogram(0, 2, 0.2)

g1 = new Graph()
g2 = new Graph()
g1.size(0, 1000, 0, 2)
g2.size(0, 2, 0, 150)
vec.plot(g1)
hist.plot(g2, .2)
</pre></blockquote>
<p>
<p><hr><p>
<h1><a name="discunif">discunif</a></h1>
<pre>
<a href="random.html#Random">Random</a>
</pre>
<h2>SYNTAX</h2>
<code>r.discunif(<var>low</var>, <var>high</var>)</code><br>
<h2>DESCRIPTION</h2>
Create a uniform random variable over the discrete integers from
low to high.
<p>
<p><hr><p>
<h1><a name="normal">normal</a></h1>
<pre>
<a href="random.html#Random">Random</a>
</pre>
<h2>SYNTAX</h2>
<code>r.normal(<var>mean</var>, <var>variance</var>)</code><br>
<h2>DESCRIPTION</h2>
Gaussian distribution.
<h2>EXAMPLES</h2>
<a href="rand1.hoc">execute following example</a>
<blockquote><pre>
objref r, g, hist, vec
r = new Random()
r.normal(-1, .5)

vec = new Vector()
vec.indgen(-3, 2, .1)	// x-axis for plot
hist = new Vector(vec.size())
g = new Graph()
g.size(-3, 2, 0, 50)
hist.plot(g, vec)
for(i=0; i&lt;500; i=i+1){
	x = r.repick()
	print i, x
	j = int((x+3)*10) // -3 to 2 -&gt; 0 to 50
	if (j &gt;= 0) {
		hist.x[j] = hist.x[j]+1
	}
	g.flush()
	doNotify()
}
</pre></blockquote>
<p>
<p><hr><p>
<h1><a name="lognormal">lognormal</a></h1>
<pre>
<a href="random.html#Random">Random</a>
</pre>
<h2>SYNTAX</h2>
<code>r.lognormal(<var>mean</var>, <var>variance</var>)</code><br>
<h2>DESCRIPTION</h2>
Create a logarithmic normal distribution.
<h2>EXAMPLES</h2>
<a href="rand2.hoc">execute following example</a>
<blockquote><pre>
objref r, g, hist, xvec
r = new Random()
r.lognormal(5,2)
n=20
xvec = new Vector(n*3)	// bins look like discrete spikes
for i=0,n-1 {
	xvec.x[3*i] = i-.1
	xvec.x[3*i+1] = i
	xvec.x[3*i+2] = i+.1
}
hist = new Vector(xvec.size())
g = new Graph()
g.size(0, 15, 0, 120)
hist.plot(g, xvec)
for(i=0; i&lt;500; i=i+1){
	x = r.repick()
	print i, x
	j = int(x)
	j = 3*j+1
	if (j &gt;= hist.size()) { // don't let any off the edge
		j = hist.size() -1
	}
	hist.x[j] = hist.x[j]+1
	g.flush()
	doNotify()
}
</pre></blockquote>
<p>
<p><hr><p>
<h1><a name="poisson">poisson</a></h1>
<pre>
<a href="random.html#Random">Random</a>
</pre>
<h2>SYNTAX</h2>
<code>r.poisson(<var>mean</var>)</code><br>
<h2>DESCRIPTION</h2>
Create a poisson distribution.
<h2>EXAMPLES</h2>
<a href="rand3.hoc">execute following example</a>
<blockquote><pre>
objref r, g, hist, xvec

r = new Random()
r.poisson(3)

n=20
xvec = new Vector(n*3)
for i=0,n-1 {
	xvec.x[3*i] = i-.1
	xvec.x[3*i+1] = i
	xvec.x[3*i+2] = i+.1
}
hist = new Vector(xvec.size())
g = new Graph()
g.size(0, 15, 0, 120)
hist.plot(g, xvec)
for(i=0; i&lt;500; i=i+1){
	x = r.repick()
	print i, x
	j = int(x)
	j = 3*j+1
	if (j &gt;= hist.size()) {
		j = hist.size() -1
	}
	hist.x[j] = hist.x[j]+1
	g.flush()
	doNotify()
}
</pre></blockquote>
<p>
<p><hr><p>
<h1><a name="binomial">binomial</a></h1>
<pre>
<a href="random.html#Random">Random</a>
</pre>
<h2>SYNTAX</h2>
<code>r.binomial(<var>N</var>,<var>p</var>)</code><br>
<h2>DESCRIPTION</h2>
Create a binomial distribution. Returns the number of "successes" after
<var>N</var> trials when the probability of a success after one trial is <var>p.</var>
(n>0, 0<=p<=1).
<p>
P(n, N, p) = p * P(n-1, N-1, p) + (1 - p) * P(n, N-1, p)
<h2>EXAMPLES</h2>
<a href="binomial.hoc">execute following example</a>
<blockquote><pre>
objref r, hist, g
r = new Random()
r.binomial(20, .5)

g = new Graph()
g.size(0, 20, 0, 100)
hist = new Vector(20)
hist.plot(g)
for(i=0; i&lt;500; i=i+1){
	j = r.repick()
	hist.x[j] = hist.x[j]+1
	g.flush()
	doNotify()
}
</pre></blockquote>
<p>
<p><hr><p>
<h1><a name="geometric">geometric</a></h1>
<pre>
<a href="random.html#Random">Random</a>
</pre>
<h2>SYNTAX</h2>
<code>r.geometric(<var>mean</var>)</code><br>
<h2>DESCRIPTION</h2>
Create a discrete geometric distribution.
Given 0<=<var>mean</var><=1, return the number of uniform random samples
that were drawn before the sample was larger than the <var>mean</var> (always
greater than 0.
<h2>EXAMPLES</h2>
<a href="geomet.hoc">execute following example</a>
<blockquote><pre>
objref r, hist, g
r = new Random()
r.geometric(.8)
hist = new Vector(1000)
proc sample() {
	hist = new Vector(1000)
	hist.setrand(r)
	hist = hist.histogram(0,100,1)
	hist.plot(g)
}
g = new Graph()
g.size(0,40,0,200)
sample()
xpanel("Resample")
xbutton("Resample", "sample()")
xpanel()
</pre></blockquote>
<p>
<p><hr><p>
<h1><a name="hypergeo">hypergeo</a></h1>
<pre>
<a href="random.html#Random">Random</a>
</pre>
<h2>SYNTAX</h2>
<code>r.hypergeo(<var>mean</var>,<var>variance</var>)</code><br>
<h2>DESCRIPTION</h2>
Create a hypergeometric distribution.
<p>
<p><hr><p>
<h1><a name="negexp">negexp</a></h1>
<pre>
<a href="random.html#Random">Random</a>
</pre>
<h2>SYNTAX</h2>
<code>r.negexp(<var>mean</var>)</code><br>
<h2>DESCRIPTION</h2>
Create a negative exponential distribution. Distributed as the intervals
between events in a poisson distribution.
<h2>EXAMPLES</h2>
<a href="negexp.hoc">execute following example</a>
<blockquote><pre>
objref r, hist, g
r = new Random() 
r.negexp(2.5) 
hist = new Vector(1000)
proc sample() {
        hist = new Vector(1000)
        hist.setrand(r)
        hist = hist.histogram(0,20,.1)
        hist.plot(g, .1)
}
g = new Graph()
g.size(0,20,0,50)
sample()
xpanel("Resample")
xbutton("Resample", "sample()")
xpanel()
</pre></blockquote>
    
<p><hr><p>
<h1><a name="erlang">erlang</a></h1>
<pre>
<a href="random.html#Random">Random</a>
</pre>
<h2>SYNTAX</h2>
<code> r.erlang(<var>mean</var>,<var>variance</var>)</code><br>
<h2>DESCRIPTION</h2>
Create an Erlang distribution.
<p>
<p><hr><p>
<h1><a name="weibull">weibull</a></h1>
<pre>
<a href="random.html#Random">Random</a>
</pre>
<h2>SYNTAX</h2>
<code> r.weibull(<var>alpha</var>,<var>beta</var>)</code><br>
<h2>DESCRIPTION</h2>
Create a Weibull distribution.
<p>
<p><hr><p>
<date>
neuron/general/classes/random.hel : Dec 14 17:48
