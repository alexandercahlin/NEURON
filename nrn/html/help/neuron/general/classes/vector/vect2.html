<p>
<p>
<h1><a name="interpolate">interpolate</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>obj = ysrcdest.interpolate(xdest, xsrc)</code><br>
<code>obj = ydest.interpolate(xdest, xsrc, ysrc)</code><br>
<h2>DESCRIPTION</h2>
Linearly interpolate points from (xsrc,ysrc) to (xdest,ydest)
In the second form, xsrc and ysrc remain unchanged.
Destination points outside the domain of xsrc are set to
ysrc[0] or ysrc[ysrc.size-1]
<h2>EXAMPLES</h2>
<a href="interp.hoc">execute following example</a>
<blockquote><pre>
//...
objref xs, ys, xd, yd
xs = new Vector(10)
xs.indgen()
ys = xs.c.mul(xs)
ys.line(g, xs, 1, 0) // black reference line

xd = new Vector()

xd.indgen(-.5, 10.5, .1)
yd = ys.c.interpolate(xd, xs)
yd.line(g, xd, 3, 0) // blue more points than reference

xd.indgen(-.5, 13, 3)
yd = ys.c.interpolate(xd, xs)
yd.line(g, xd, 2, 0) // red fewer points than reference
</pre></blockquote>
<p>
<p><hr><p>
<h1><a name="deriv">deriv</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>obj = vdest.deriv(vsrc)</code><br>
<code>obj = vdest.deriv(vsrc, <var>dx</var>)</code><br>
<code>obj = vdest.deriv(vsrc, <var>dx</var>, <var>method</var>)</code><br>
<code>obj = vsrcdest.deriv()</code><br>
<code>obj = vsrcdest.deriv(<var>dx</var>)</code><br>
<code>obj = vsrcdest.deriv(<var>dx</var>, <var>method</var>)</code><br>
<h2>DESCRIPTION</h2>
The numerical Euler derivative or the central difference derivative of <code>vec</code> 
is placed in <code>vdest</code>.  
The variable <code><var>dx</var></code> gives the increment of the independent variable
between successive elements of <code>vec</code>.  
<dl>
<dt> <code><var>method</var></code> = 1 = Euler derivative:
<dd> <code>vec1[<var>i</var>] = (vec[<var>i</var>+1] - vec[<var>i</var>])/<var>dx</var></code> <br>
Each time this method is used, 
the first element 
of <code>vec</code> is lost since <var>i</var> cannot equal -1.  Therefore, since the 
<code>integral</code> function performs an Euler
integration, the integral of <code>vec1</code> will reproduce <code>vec</code> minus the first 
element.  
<dt> <code><var>method</var></code> = 2 = Central difference derivative:
<dd> <code>vec1[<var>i</var>] = ((vec[<var>i</var>+1]-vec[<var>i</var>-1])/2)/<var>dx</var></code> <br>
This method produces an Euler derivative for the first and last
elements of <code>vec1</code>.  The central difference method maintains the 
same number of elements in <code>vec1</code>
as were in <code>vec</code> and is a more accurate method than the Euler method. 
A vector differentiated by this method cannot, however, be integrated 
to reproduce the original <code>vec</code>.
</dl>
 
<h2>EXAMPLES</h2>
<blockquote><pre>
objref vec, vec1
vec = new Vector()
vec1 = new Vector()
vec.indgen(0, 5, 1)
func sq(){
	return $1*$1
}
vec.apply("sq")
vec1.deriv(vec, 0.1)
</pre></blockquote>
creates <code>vec1</code> with elements:
<pre>
10	20	
40	60	
80	90
</pre>
Since <code><var>dx</var></code>=0.1, and there are eleven elements including 0,
 the entire function exists between the values of 0 and 1, and the derivative
values are large compared to the function values. With <code><var>dx</var></code>=1,the vector
<code>vec1</code> would consist of the following elements:
<pre>
1	2	
4	6	
8	9
</pre>
<p>
The Euler method vs. the Central difference method:<br>
Beginning with the vector <code>vec</code>:
<pre>
0	1	
4	9	
16	25
</pre>
<code>vec1.deriv(vec, 1, 1)</code> (Euler) would go about 
producing <code>vec1</code> by the following method:
<pre>
1-0   = 1	4-1  = 3		
9-4   = 5	16-9 = 7	
25-16 = 9
</pre>
whereas <code>vec1.deriv(vec, 1, 2)</code> (Central difference) would go about 
producing <code>vec1</code> as such:
<pre>
1-0      = 1		(4-0)/2  = 2	
(9-1)/2  = 4		(16-4)/2 = 6	
(25-9)/2 = 8		25-16    = 9
</pre>
<p>
<p><hr><p>
<h1><a name="integral">integral</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>obj = vdest.integral(vsrc)</code><br>
<code>obj = vdest.integral(vsrc, <var>dx</var>)</code><br>
<code>obj = vsrcdest.integral()</code><br>
<code>obj = vsrcdest.integral(<var>dx</var>)</code><br>
<h2>DESCRIPTION</h2>
Places a numerical Euler integral of the vsrc elements in vdest.
<code><var>dx</var></code> sets the size of the discretization.
<p>
<code>vdest[i+1] = vdest[i] + vsrc[i+1]</code> and the first element of <code>vdest</code> is always
equal to the first element of <code>vsrc</code>.
<h2>EXAMPLES</h2>
<blockquote><pre>
objref vec, vec1
vec = new Vector()
vec1 = new Vector()
vec.indgen(0, 5, 1)	//vec will have 6 values from 0 to 5, with increment=1
vec.apply("sq")		//sq() squares an element 
			//and is defined in the example for .deriv
vec1.integral(vec, 1)	//Euler integral of vec elements approximating
			//an x-squared function, dx = 0.1
vec1.printf()
</pre></blockquote>
will print the following elements in <code>vec1</code> to the screen:
<pre>
0	1	5	
14	30	55
</pre>
In order to make the integral values more accurate, it is necessary to increase
 the size of the vector and to decrease the size of <var>dx.</var>
<blockquote><pre>
objref vec2
vec2 = new Vector(6)
vec.indgen(0, 5.1, 0.1)	//vec will have 51 values from 0 to 5, with increment=0.1
vec.apply("sq")		//sq() squares an element 
			//and is defined in the example for .deriv
vec1.integral(vec, 0.1)	//Euler integral of vec elements approximating
			//an x-squared function, dx = 0.1
for i=0,5{vec2.x[i] = vec1.x[i*10]}  //put the value of every 10th index in vec2
vec2.printf()
</pre></blockquote>
will print the following elements in <code>vec2</code> (which are the elements of
<code>vec1</code> corresponding to the integers 0-5) to the screen:
<pre>
0	0.385	2.87
9.455	22.14	42.925
</pre>
The integration naturally becomes more accurate as
<var>dx</var> is reduced and the size of the vector is increased.  If the vector 
is taken to 501 elements from 0-5 and <var>dx</var> is made to equal 0.01, the integrals
of the integers 0-5 yield the following (compared to their continuous values
on their right).
<pre>
0.00000 -- 0.00000	0.33835 --  0.33333	2.6867  --  2.6666
9.04505 -- 9.00000	21.4134 -- 21.3333	41.7917 -- 41.6666
</pre>	
<p>
<p><hr><p>
<h1><a name="median">median</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>median = vsrc.median()</code><br>
<h2>DESCRIPTION</h2>
Find the median value of <code>vec</code>.
<p>
<p><hr><p>
<h1><a name="medfltr">medfltr</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>obj = vdest.medfltr(vsrc)</code><br>
<code>obj = vdest.medfltr(vsrc, <var>points</var>)</code><br>
<code>obj = vsrcdest.medfltr()</code><br>
<code>obj = vsrcdest.medfltr( <var>points</var>)</code><br>
<h2>DESCRIPTION</h2>
Apply a median filter to vsrc, producing a smoothed version in vdest.
Each point is replaced with the median value of the <var>points</var> on
either side. 
This is typically used for eliminating spikes from data.
<p>
<p><hr><p>
<h1><a name="sort">sort</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>obj = vsrcdest.sort()</code><br>
<h2>DESCRIPTION</h2>
Sort the elements of <code>vec1</code> in place, putting them in numerical order.
<p>
<p><hr><p>
<h1><a name="sortindex">sortindex</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>vdest = vsrc.sortindex()</code><br>
<code>vdest = vsrc.sortindex(vdest)</code><br>
<h2>DESCRIPTION</h2>
Return a new vector of indices which sort the vsrc elements in numerical
order. That is vsrc.index(vsrc.sortindex) is equivalent to vsrc.sort().
If vdest is present, use that as the destination vector for the indices.
This, if it is large enough, avoids the destruct/construct of vdest.
<h2>EXAMPLES</h2>
<a href="sortindx.hoc">execute following example</a>
<blockquote><pre>
objref a, r, si
r = new Random()
r.uniform(0,100)
a = new Vector(10)
a.setrand(r)
a.printf

si = a.sortindex
si.printf
a.index(si).printf
</pre></blockquote>
<p>
<p>
<p><hr><p>
<h1><a name="reverse">reverse</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>obj = vsrcdest.reverse()</code><br>
<h2>DESCRIPTION</h2>
Reverses the elements of <code>vec</code> in place.
<p>
<p><hr><p>
<h1><a name="rotate">rotate</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>obj = vsrcdest.rotate(<var>value</var>)</code><br>
<code>obj = vsrcdest.rotate(<var>value</var>, 0)</code><br>
<h2>DESCRIPTION</h2>
A negative <var>value</var> will move elements to the left.  A positive argument
will move elements to the right.  In both cases, the elements shifted off one
end of the vector will reappear at the other end.
If a 2nd arg is present, 0 values get shifted in and elements shifted off
one end are lost.
<h2>EXAMPLES</h2>
<blockquote><pre>
vec.indgen(1, 10, 1)
vec.rotate(3)
</pre></blockquote>
orders the elements of <code>vec</code> as follows:
<pre>
8  9  10  1  2  3  4  5  6  7
</pre>
whereas,
<blockquote><pre>
vec.indgen(1, 10, 1)
vec.rotate(-3)
</pre></blockquote>
orders the elements of <code>vec</code> as follows:
<pre>
4  5  6  7  8  9  10  1  2  3
</pre>
<a href="rotate.hoc">execute following example</a>
<blockquote><pre>
objref vec
vec = new Vector()
vec.indgen(1,5,1)
vec.printf
vec.c.rotate(2).printf
vec.c.rotate(2, 0).printf
vec.c.rotate(-2).printf
vec.c.rotate(-2, 0).printf
</pre></blockquote>
<p>
<p><hr><p>
<h1><a name="rebin">rebin</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>obj = vdest.rebin(vsrc,<var>factor</var>)</code><br>
<code>obj = vsrcdest.rebin(<var>factor</var>)</code><br>
<h2>DESCRIPTION</h2>
Compresses length of vector <code>vsrc</code> by an integer <var>factor.</var>  The sum of 
elements is conserved, unless the <var>factor</var> produces a remainder, 
in which case the remainder values are truncated from <code>vdest</code>.
<h2>EXAMPLES</h2>
<blockquote><pre>
vec.indgen(1, 10, 1)
vec1.rebin(vec, 2)
</pre></blockquote>
produces <code>vec1</code>:
<pre>
3  7  11  15  19
</pre>
where each pair of <code>vec </code> elements is added together into one element.
<p>
But,
<blockquote><pre>
vec.indgen(1, 10, 1)
vec1.rebin(vec, 3)
</pre></blockquote>
adds trios <code>vec</code> elements and gets rid of the value 10, producing
<code>vec1</code>:
<pre>
6  15  24
</pre>
<p>
<p><hr><p>
<h1><a name="pow">pow</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>obj = vdest.pow(vsrc, <var>power</var>)</code><br>
<code>obj = vsrcdest.pow(<var>power</var>)</code><br>
<h2>DESCRIPTION</h2>
Raise each element to some power. A power of -1, 0, .5, 1, or 2
are efficient.
<p>
<p><hr><p>
<h1><a name="sqrt">sqrt</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>obj = vdest.sqrt(vsrc)</code><br>
<code>obj = vsrcdest.sqrt()</code><br>
<h2>DESCRIPTION</h2>
Take the square root of each element. No domain checking.
<p>
<p><hr><p>
<h1><a name="log">log</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>obj = vdest.log(vsrc)</code><br>
<code>obj = vsrcdest.log()</code><br>
<h2>DESCRIPTION</h2>
Take the natural log of each element. No domain checking.
<p>
<p><hr><p>
<h1><a name="log10">log10</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>obj = vdest.log10(vsrc)</code><br>
<code>obj = vsrcdest.log10()</code><br>
<h2>DESCRIPTION</h2>
Take the logarithm to the base 10 of each element. No domain checking.
<p>
<p><hr><p>
<h1><a name="tanh">tanh</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>obj = vdest.tanh(vsrc)</code><br>
<code>obj = vsrcdest.tanh()</code><br>
<h2>DESCRIPTION</h2>
Take the hyperbolic tangent of each element.
<p>
<p><hr><p>
<h1><a name="abs">abs</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>obj = vdest.abs(vsrc)</code><br>
<code>obj = vsrcdest.abs()</code><br>
<h2>DESCRIPTION</h2>
Take the absolute value of each element.
<h2>EXAMPLES</h2>
<blockquote><pre>
objref v1
v1 = new Vector()
v1.indgen(-.5, .5, .1)
v1.printf()
v1.abs.printf()
</pre></blockquote>
<h2>SEE ALSO</h2>
<a href="../../function/sin.html#math">math</a>
<p>
<p><hr><p>
<h1><a name="index">index</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>obj = vdest.index(vsrc,  <var>indices</var>)</code><br>
<h2>DESCRIPTION</h2>
The values of the vector <code>vsrc</code> indexed by the vector <var>indices</var> are collected
into <code>vdest</code>.
<p>
<h2>EXAMPLES</h2>
<blockquote><pre>
objref vec, vec1, vec2, vec3
vec = new Vector()
vec1 = new Vector()
vec2 = new Vector()
vec3 = new Vector(6)
vec.indgen(0, 5.1, 0.1)	//vec will have 51 values from 0 to 5, with increment=0.1
vec1.integral(vec, 0.1)	//Euler integral of vec elements approximating
			//an x-squared function, dx = 0.1
vec2.indgen(0, 50,10)
vec3.index(vec1, vec2)  //put the value of every 10th index in vec2
</pre></blockquote>
makes <code>vec3</code> with six elements corresponding to the integrated integers from 
<code>vec</code>.
<p>
<p><hr><p>
<h1><a name="min">min</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>x = vec.min()</code><br>
<code>x = vec.min(<var>start</var>, <var>end</var>)</code><br>
<h2>DESCRIPTION</h2>
Return the minimum value.
<p>
<p><hr><p>
<h1><a name="min_ind">min_ind</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>i = vec.min_ind()</code><br>
<code>i = vec.min_ind(<var>start</var>, <var>end</var>)</code><br>
<h2>DESCRIPTION</h2>
Return the index of the minimum value.
<p>
<p><hr><p>
<h1><a name="max">max</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>x = vec.max()</code><br>
<code>x = vec.max(<var>start</var>, <var>end</var>)</code><br>
<h2>DESCRIPTION</h2>
Return the maximum value.
<p>
<p><hr><p>
<h1><a name="max_ind">max_ind</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>i = vec.max_ind()</code><br>
<code>i = vec.max_ind(<var>start</var>, <var>end</var>)</code><br>
<h2>DESCRIPTION</h2>
Return the index of the maximum value.
<p>
<p><hr><p>
<h1><a name="sum">sum</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>x = vec.sum()</code><br>
<code>x = vec.sum(<var>start</var>, <var>end</var>)</code><br>
<h2>DESCRIPTION</h2>
Return the sum of element values.
<p>
<p><hr><p>
<h1><a name="sumsq">sumsq</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>x = vec.sumsq()</code><br>
<code>x = vec.sumsq(<var>start</var>, <var>end</var>)</code><br>
<h2>DESCRIPTION</h2>
Return the sum of squared element values.
<p>
<p><hr><p>
<h1><a name="mean">mean</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>x =  vec.mean()</code><br>
<code>x =  vec.mean(<var>start</var>, <var>end</var>)</code><br>
<h2>DESCRIPTION</h2>
Return the mean of element values.
<p>
<p><hr><p>
<h1><a name="var">var</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>x = vec.var()</code><br>
<code>x = vec.var(<var>start</var>, <var>end</var>)</code><br>
<h2>DESCRIPTION</h2>
Return the variance of element values.
<p>
<p><hr><p>
<h1><a name="stdev">stdev</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>vec.stdev()</code><br>
<code>vec.stdev(<var>start</var>,<var>end</var>)</code><br>
<h2>DESCRIPTION</h2>
Return the standard deviation of the element values.
<p>
<p><hr><p>
<h1><a name="stderr">stderr</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>x = vec.stderr()</code><br>
<code>x = vec.stderr(<var>start</var>, <var>end</var>)</code><br>
<h2>DESCRIPTION</h2>
Return the standard error of the mean (SEM) of the element values.
<p>
<p><hr><p>
<h1><a name="dot">dot</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>x = vec.dot(<var>vec1</var>)</code><br>
<h2>DESCRIPTION</h2>
Return the dot (inner) product of <code>vec</code> and <var>vec1.</var>
<p>
<p><hr><p>
<h1><a name="mag">mag</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>x = vec.mag()</code><br>
<h2>DESCRIPTION</h2>
Return the vector length or magnitude.
<p>
<p><hr><p>
<h1><a name="add">add</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>obj = vsrcdest.add(<var>scalar</var>)</code><br>
<code>obj = vsrcdest.add(<var>vec1</var>)</code><br>
<h2>DESCRIPTION</h2>
Add either a scalar to each element of the vector or add the corresponding
elements of <var>vec1</var> to the elements of <code>vsrcdest</code>.
<code>vsrcdest</code> and <var>vec1</var> must have the same size.
<p>
<p><hr><p>
<h1><a name="sub">sub</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>obj = vsrcdest.sub(<var>scalar</var>)</code><br>
<code>obj = vsrcdest.sub(<var>vec1</var>)</code><br>
<h2>DESCRIPTION</h2>
Subtract either a scalar from each element of the vector or subtract the
corresponding elements of <var>vec1</var> from the elements of <code>vsrcdest</code>.
<code>vsrcdest</code> and <var>vec1</var> must have the same size.
<p>
<p><hr><p>
<h1><a name="mul">mul</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>obj = vsrcdest.mul(<var>scalar</var>)</code><br>
<code>obj = vsrcdest.mul(<var>vec1</var>)</code><br>
<h2>DESCRIPTION</h2>
Multiply each element of <code>vsrcdest</code> either by either a scalar or the
corresponding elements of <var>vec1.</var>  <code>vsrcdest</code> 
and <var>vec1</var> must have the same size.
<p>
<p><hr><p>
<h1><a name="div">div</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>obj = vsrcdest.div(<var>scalar</var>)</code><br>
<code>obj = vsrcdest.div(<var>vec1</var>)</code><br>
<h2>DESCRIPTION</h2>
Divide each element of <code>vsrcdest</code> either by a scalar or by the
corresponding elements of <var>vec1.</var>  <code>vsrcdest</code> 
and <var>vec1</var> must have the same size.
<p>
<p><hr><p>
<h1><a name="scale">scale</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>scale = vsrcdest.scale(<var>low</var>, <var>high</var>)</code><br>
<h2>DESCRIPTION</h2>
Scale values of the elements of a vector to lie within the given range.
Return the scale factor used.
<p>
<p><hr><p>
<h1><a name="eq">eq</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>boolean = vec.eq(<var>vec1</var>)</code><br>
<h2>DESCRIPTION</h2>
Test equality of vectors.  Returns 1 if all elements of vec ==
corresponding elements of <var>vec1</var> (to within <a href="../../predec.html#float_epsilon">float_epsilon</a> ).
Otherwise it returns 0.
<p>
<p><hr><p>
<h1><a name="meansqerr">meansqerr</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
</pre>
<h2>SYNTAX</h2>
<code>x = vec.meansqerr(<var>vec1</var>)</code><br>
<code>x = vec.meansqerr(<var>vec1</var>, <var>weight_vec</var>)</code><br>
<h2>DESCRIPTION</h2>
Return the mean squared error between values of the elements of <code>vec</code> and
the corresponding elements of <var>vec1.</var>  <code>vec</code> and <var>vec1</var> must have the
same size.
<p>
If the second vector arg is present, it also must have the same size and the
return value is sum of w[i]*(v1[i] - v2[i])^2 / size
<p>
<p><hr><p>
<h1><a name="Fourier">Fourier</a></h1>
<pre>
<a href="vect.html#Vector">Vector</a>
   <a href="vect2.html#convlv">convlv</a>         <a href="vect2.html#fft">fft</a>            <a href="vect2.html#spctrm">spctrm</a>         
   <a href="vect2.html#correl">correl</a>         <a href="vect2.html#filter">filter</a>         
</pre>
The following routines are based on the fast fourier transform (FFT)
and are implemented using code from Numerical Recipes in C (2nd ed.)
Refer to this source for further information.
<p>
<p><hr><p>
<h1><a name="correl">correl</a></h1>
<pre>
<a href="vect2.html#Fourier">Fourier</a>
</pre>
<h2>SYNTAX</h2>
<code>obj = vdest.correl(<var>src</var>)</code><br>
<code>obj = vdest.correl(<var>src</var>, <var>vec2</var>)</code><br>
<h2>DESCRIPTION</h2>
Compute the cross-correlation function of <var>src</var> and <var>vec2</var> (or the
autocorrelation of <var>src</var> if <var>vec2</var> is not present).
<p>
<p><hr><p>
<h1><a name="convlv">convlv</a></h1>
<pre>
<a href="vect2.html#Fourier">Fourier</a>
</pre>
<h2>SYNTAX</h2>
<code>obj = vdest.convlv(<var>src</var>,<var>filter</var>)</code><br>
<code>obj = vdest.convlv(<var>src</var>,<var>filter</var>, <var>sign</var>)</code><br>
<h2>DESCRIPTION</h2>
Compute the convolution of <var>src</var> with <var>filter.</var>  If <sign>=-1 then
compute the deconvolution.
Assumes filter is given in "wrap-around" order, with countup
<code>t=0..t=n/2</code> followed by countdown <code>t=n..t=n/2</code>.  The size of <var>filter</var>
should be an odd <= the size of <var>v1</var>>.
<h2>EXAMPLES</h2>
<a href="convlv.hoc">execute following example</a>
<blockquote><pre>
objref v1, v2, v3
v1 = new Vector(16)
v2 = new Vector(16)
v3 = new Vector()
v1.x[5] = v1.x[6] = 1
v2.x[3] = v2.x[4] = 3
v3.convlv(v1, v2)
v1.printf()
v2.printf()
v3.printf()
</pre></blockquote>
<p>
<p><hr><p>
<h1><a name="spctrm">spctrm</a></h1>
<pre>
<a href="vect2.html#Fourier">Fourier</a>
</pre>
<h2>SYNTAX</h2>
<code>obj = vdest.spctrm(vsrc)</code><br>
<h2>DESCRIPTION</h2>
Return the power spectral density function of vsrc.
<p>
<p><hr><p>
<h1><a name="filter">filter</a></h1>
<pre>
<a href="vect2.html#Fourier">Fourier</a>
</pre>
<h2>SYNTAX</h2>
<code>obj = vdest.filter(src,<var>filter</var>)</code><br>
<code>obj = vsrcdest.filter(<var>filter</var>)</code><br>
<h2>DESCRIPTION</h2>
Digital filter implemented by taking the inverse fft of 
<var>filter</var> and convolving it with <var>vec1.</var>  <var>vec</var> and <var>vec1</var> 
are in the time
domain and <var>filter</var> is in the frequency domain.
<p>
<p><hr><p>
<h1><a name="fft">fft</a></h1>
<pre>
<a href="vect2.html#Fourier">Fourier</a>
</pre>
<h2>SYNTAX</h2>
<code>obj = vdest.fft(vsrc, <var>sign</var>)</code><br>
<code>obj = vsrcdest.fft(<var>sign</var>)</code><br>
<h2>DESCRIPTION</h2>
Compute the fast fourier transform of the source data vector.  If
<var>sign</var>=-1 then compute the inverse fft.
<p>
If vsrc.size() is not an integral power of 2, it is padded with 0's to
the next power of 2 size.
<p>
The complex frequency domain is represented in the vector as pairs of
numbers --- except for the first two numbers.
vec.x[0] is the amplitude of the 0 frequency cosine (constant)
and vec.x[1] is the amplitude of the highest (N/2) frequency cosine
(ie. alternating 1,-1's in the time domain)
vec.x[2, 3] is the amplitude of the cos(2*PI*i/n), sin(2*PI*i/n) components
(ie. one whole wave in the time domain)
vec.x[n-2, n-1] is the amplitude of the cos(PI*(n-1)*i/n), sin(PI*(n-1)*i/n)
components. The following example of a pure time domain sine wave
sampled at 16 points should be played with to see where
the specified frequency appears in the frequency domain vector (note that if the
frequency is greater than 8, aliasing will occur, ie sampling makes it appear
as a lower frequency)
Also note that the forward transform does not produce the amplitudes of
the frequency components that goes up to make the time domain function but
instead each element is the integral of the product of the time domain
function and a specific pure frequency. Thus the 0 and highest frequency
cosine are N times the amplitudes and all others are N/2 times the amplitudes.
<p>
<a href="fft1.hoc">execute following example</a>
<blockquote><pre>...	//define a gui for this example

N=16	// should be power of 2
c=1	// 0 -&gt; sin   1 -&gt; cos
f=1	// waves per domain, max is N/2
setup_gui() // construct the gui for this example

proc p() {
        v1 = new Vector(N)
        v1.sin(f, c*PI/2, 1000/N)
        v1.plot(g1)
                
        v2 = new Vector()
        v2.fft(v1, 1)		// forward
        v2.plot(g2)
        
	v3 = new Vector()
	v3.fft(v2, -1)		// inverse
	v3.plot(g3)		// amplitude N/2 times the original 
}
        
p()
</pre></blockquote>
<p>
The inverse fft is mathematically almost identical
to the forward transform but often
has a different operational interpretation. In this
case the result is a time domain function which is merely the sum
of all the pure sinusoids weighted by the (complex) frequency function
(although, remember, points 0 and 1 in the frequency domain are special,
being the constant and the highest alternating cosine, respectively).
The example below shows the index of a particular frequency and phase
as well as the time domain pattern. Note that index 1 is for the higest
frequency cosine instead of the 0 frequency sin.
<p>
Because the frequency domain representation is something only a programmer
could love, and because one might wish to plot the real and imaginary
frequency spectra, one might wish to encapsulate the fft in a function
which uses a more convenient representation.
<p>
Below is an alternative FFT function where the frequency
values are spectrum amplitudes (no need to divide anything by N)
and the real and complex frequency components are
stored in separate vectors (of length N/2 + 1).
<p>
Consider the functions
<h2>SYNTAX</h2>
<code>FFT(1, vt_src, vfr_dest, vfi_dest)</code><br>
<code>FFT(-1, vt_dest, vfr_src, vfi_src)</code><br>
<h2>DESCRIPTION</h2>
<p>
The forward transform (first arg = 1) requires
a time domain source vector with a length of N = 2^n where n is some positive
integer. The resultant real (cosine amplitudes) and imaginary (sine amplitudes)
frequency components are stored in the N/2 + 1
locations of the vfr_dest and vfi_dest vectors respectively (Note:
vfi_dest.x[0] and vfi_dest.x[N/2] are always set to 0. The index i in the
frequency domain is the number of full pure sinusoid waves in the time domain.
ie. if the time domain has length T then the frequency of the i'th component
is i/T.
<p>
The inverse transform (first arg = -1) requires two freqency domain
source vectors for the cosine and sine amplitudes. The size of these
vectors must be N/2+1 where N is a power of 2. The resultant time domain
vector will have a size of N.
<p>
If the source vectors are not a power of 2, then the vectors are padded
with 0's til vtsrc is 2^n or vfr_src is 2^n + 1. The destination vectors
are resized if necessary.
<p>
This function has the property that the sequence
<blockquote><pre>
FFT(1, vt, vfr, vfi)
FFT(-1, vt, vfr, vfi)
</pre></blockquote>
leaves vt unchanged. Reversal of the order would leave vfr and vfi unchanged.
<p>
The implementation is:<br>
<a href="fft3.hoc">execute following example</a>
<blockquote><pre>
proc FFT() {local n, x
        if ($1 == 1) { // forward
                $o3.fft($o2, 1)
                n = $o3.size()
                $o3.div(n/2)
                $o3.x[0] /= 2	// makes the spectrum appear discontinuous
                $o3.x[1] /= 2	// but the amplitudes are intuitive

                $o4.copy($o3, 0, 1, -1, 1, 2)   // odd elements
                $o3.copy($o3, 0, 0, -1, 1, 2)   // even elements
                $o3.resize(n/2+1)
                $o4.resize(n/2+1)
                $o3.x[n/2] = $o4.x[0]           //highest cos started in o3.x[1
                $o4.x[0] = $o4.x[n/2] = 0       // weights for sin(0*i)and sin(PI*i)
	}else{ // inverse
                // shuffle o3 and o4 into o2
                n = $o3.size()
                $o2.copy($o3, 0, 0, n-2, 2, 1)
                $o2.x[1] = $o3.x[n-1]
                $o2.copy($o4, 3, 1, n-2, 2, 1)
                $o2.x[0] *= 2
                $o2.x[1] *= 2 
                $o2.fft($o2, -1)
        }
}
</pre></blockquote>
If you load the previous example so that FFT is defined, the following
example shows the cosine and sine spectra of a pulse. <br>
<a href="fft4.hoc">execute following example</a>
<blockquote><pre>...
N=128
delay = 0
duration = N/2
setup_gui()
proc p() {
        v1 = new Vector(N)
        v1.fill(1, delay, delay+duration-1)
        v1.plot(g1)
                
        v2 = new Vector()
        v3 = new Vector()
        FFT(1, v1, v2, v3)
        v2.plot(g2)
        v3.plot(g3)
                
        v4 = new Vector()
        FFT(-1, v4, v2, v3)
        v4.plot(g4)
}
p()

</pre></blockquote>
<h2>SEE ALSO</h2>
<a href="vect2.html#fft">fft</a> <a href="vect2.html#spctrm">spctrm</a>
<p><hr><p>
<date>
neuron/general/classes/vector/vect2.hel : Sep 21 09:30
